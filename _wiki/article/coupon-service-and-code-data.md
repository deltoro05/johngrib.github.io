---
layout  : wiki
title   : 더 나은 쿠폰 서비스에 대한 아이디어 기록
summary : 
date    : 2022-08-28 15:28:07 +0900
updated : 2022-09-01 22:11:11 +0900
tag     : 아이디어
toc     : true
public  : true
parent  : [[/article]]
latex   : false
---
* TOC
{:toc}

## 쿠폰 서비스

구현이 꽤나 까다로운 서비스의 한 예로 일반적인 이커머스에서 사용하는 쿠폰 서비스를 들 수 있다고 생각한다.

쿠폰은 구현할 때 생각해야 하는 특징들의 조합이 꽤나 많으며,
비즈니스 상황에 따라 새로운 종류의 쿠폰을 계속 추가해 나가야 하는 문제도 덩달아 안고 있는 편이다.

## 사례: 급하게 만든 쿠폰 서비스

다음과 같이 쿠폰 서비스를 갖추게 되는 밑바닥부터 시작하는 스타트업 쇼핑몰이 있다고 상상해 보자.

1. 쇼핑몰에 쿠폰 기능이 필요해짐.
2. 기획자가 최소한의 기능만 갖는 쿠폰 서비스를 기획한다.
3. 개발자는 1~2달간 기획서의 내용대로 쿠폰 서비스를 개발한다.
4. 일정에 맞춰 배포한다. 이제 쇼핑몰에 간단한 쿠폰 기능이 추가되었다.

이렇게 만든 쿠폰은 아주 간단한 형태로 다음과 같은 기능만 갖고 있다고 하자.

- 특정 카테고리의 상품이 주문서에 있다면 사용 가능한 쿠폰을 만들 수 있다.
- 쿠폰을 적용하면 쿠폰이 적용된 상품의 가격을 고정 금액으로 할인해준다.

다음은 쿠폰 적용 판별 함수를 대충 작성해 본 것이다.

```java
boolean isAvailableCoupon(Coupon c, OrderSheet o) {
  if (CATEGORY_ALLOW == c.type && c.category != null && o.size() > 0) {
    // 카테고리 허용 쿠폰이라면 주문서에 해당 카테고리 상품이 있나 확인한다
    for (OrderProduct product : o) {
      if (c.category.equals(product.getCategory()) {
        return true;
      }
    }
    // 주문서에 해당 카테고리 상품이 없으므로 쿠폰을 사용할 수 없음
    return false;
  }
}
```

그런데 문제는 이 다음부터이다.
마케팅 부서가 약 3주마다 새로운 종류의 쿠폰을 만들 수 있게 해달라는 요청을 보내게 된 것이다.

- A 신용카드사와 계약을 했습니다. A 신용카드로 결제하는 경우에만 쓸 수 있는 쿠폰이 필요해요.
- 음반 쿠폰이 필요합니다. 이 쿠폰은 주문서에 2020년에 발매된 음반들만 있고 다른 상품이 전혀 없을 때에만 쓸 수 있어야 해요.
- 추석 선물세트가 들어있을 경우 배송비를 무료로 해주는 쿠폰이 필요해요.
- 10만원 이상 구매하는 경우에만 1000원을 할인해주는 쿠폰이 필요해요.

계속해서 새로운 종류의 쿠폰을 만들어 달라고 하는 것은 쿠폰이라는 도메인의 특성이다.
그런데 문제는 이런 종류의 작업들은 마케팅 비즈니스와 관련이 있고, 시기를 잘 타야 이익을 극대화할 수 있다는 특징이 있다.

### 플로우 차트 모델: 끝없이 추가되는 if / else

즉 처음엔 최소한의 기능만 구현해놓고 배포가 완료된 이후 서서히 새로운 요구 조건들이 쏟아지게 된다.
따라서 이런 요구 사항들을 빠르게 들어주기 위해 엄청난 양의 `if`/`else`가 쿠폰 사용 조건을 판별하는 모듈에 들어가게 될 수 있다.

```java
boolean isAvailableCoupon(Coupon c, OrderSheet o, Payment p) {
  // if 카테고리 허용 쿠폰이라면 주문서에 해당 카테고리 상품이 있나?
    return ...;

  // if 특정 결제수단 쿠폰이라면 결제를 A 신용카드로 진행했나?
    return ...;

  // if 특정 연도에 판매된 상품들로 구성된 주문서인가?
    return ...;

  // 결제 금액이 특정 가격을 넘어서는가?
    return ...;

  // ... 그 외에 수없이 이어지는 if / else
}
```

위의 예제는 간단하게 주석으로 표기했지만 `isAvailableCoupon` 메소드는 시간이 지남에 따라 굉장히 큰 코드가 되어간다.
단순한 메소드 추출로는 근본적인 문제를 해결할 수 없다.
모듈을 여러 클래스로 분리한다 가정해도 막대한 양의 `if`/`else`를 관리하고 테스트 코드를 작성하는 것도 쉬운 일이 아니기 때문이다.

따라서 간단한 종류의 쿠폰만을 만들고 쿠폰의 종류나 조합의 경우의 수를 증가시키지 않는 방향으로 핸들링하기도 한다.
쿠폰에 새로운 조건을 추가하게 된다면 모든 if 문을 읽고 어떤 위치에 새로운 if 문을 추가해야 할 지 판단해야 할 텐데, 조건이 추가될수록 난이도가 급상승하기 때문이다.

이러한 복잡도의 원인은 쿠폰의 적용/검증 과정을 하나의 플로우 차트 모델로 생각하고 구현했기 때문이다.
새로운 요구사항이 도착하면 플로우 차트에 새로운 `if`를 추가하는 것이 문제인 것.

그리고 이런 과정을 통해 수십~수백개의 `if`/`else`가 쌓이게 되면 쿠폰을 구성하는 다양한 조건들의 우선순위와 처리 과정을 명확하게 이해하는 사람이 점점 줄어들게 된다. 관리자 화면에 보이는 여러 데이터들의 우선순위를 모르면 의도와 다르게 작동하는 엉뚱한 쿠폰이 만들어질 수도 있다.

#### 왜 이렇게 구현하게 되나?

DB에 쿠폰의 로직이 작동할 기준이 되는 값들을 저장한다고 생각해보자.
RDB는 예제를 만들기엔 좀 골치아프니 다음과 같이 json 형태로 Document DB에 저장한다고 하자.

```js
{
  "id": "B2E0DF55-3C57-493D-A866-3FDF4B4FDA9",
  "name": "가전제품 10% 할인 쿠폰",
  "condition": {
    "allowType": "CATEGORY",
    "allowList": [112], // 가전제품,
    "disallowType": "NONE",
    "disallowList": []
  },
  "discount": {
    "type": "RATIO",
    "value": 10,    // 10% 할인
    "max": 10000    // 최대 1만원까지만 할인
  }
}
```

이렇게 저장한 데이터에는 쿠폰과 관련된 판단의 기준이 되는 값들은 포함되어 있지만, 쿠폰과 관련된 로직은 포함되어 있지 않다. 로직을 전부 소스코드에 위치시킬 수 밖에 없으므로 쿠폰의 종류가 늘어날수록 소스코드 또한 복잡해지게 된다.

만약 쿠폰을 DB에 저장할 때 해당 쿠폰의 판별, 할인 적용 로직도 함께 저장할 수 있다면 쿠폰과 관련된 코드는 단순해질 것이다. 잘 구현한다면 `if`는 대폭 줄어들고, 한 두개의 `for`만 남게될 수도 있다.

## 파이프라인 모델

나는 과거에 레거시 쿠폰 서비스를 리팩토링하다가 다음과 같이 [[/pattern/pipeline]] 패턴과 로직을 DB에 저장하는 기법을 조합해 응용하는 방법을 떠올린 적이 있다.

![]( ./pipeline-coupon.svg )

녹색 네모칸, 즉 체커와 할인 적용기를 컴포넌트라 부르도록 하자.
각 컴포넌트는 다음과 같은 간단한 인터페이스의 구현체로 만든다.

```java
interface CouponComponent {
  /**
   * 파이프라인을 통과할 수 있다면 true를 리턴합니다.
   */
  default boolean isPass(Context c) {
    return true;
  }

  /**
   * 파이프라인을 적용한 결과를 리턴합니다.
   */
  default Context apply(Context c) {
    return c;
  }
}
```

이제 이 인터페이스의 구현체를 목적에 따라 다양하게 만들면 된다.
예를 들어 다음과 같이 만들 수 있을 것이다.

- 예: 카테고리 체크 컴포넌트

```java
class CategoryComponent implements CouponComponent {
  // 생성자 생략
  private Set<Category> categories;

  boolean isPass(Context c) {
    // 해당하는 카테고리 상품이 있다면 true
    for (OrderProduct p : c.getOrderSheet().getOrderProducts()) {
      if (categories.contains(p.getCategory()) {
        return true;
      }
    }
    // 해당 카테고리가 없다면 false
    return false;
  }
}
```

- 예: 최소금액 체크 컴포넌트

```java
class MinimumPriceComponent implements CouponComponent {
  // 생성자 생략
  private int minPrice;

  boolean isPass(Context c) {
    return c.getOrderSheet().getTotalPrice() >= minimumPrice;
  }
}
```

- 예: 고정금액 할인 컴포넌트

```java
class DiscountFixed implements CouponComponent {
  // 생성자 생략
  private int discountPrice;

  boolean isPass(Context c) {
    return c.getOrderSheet().getTotalPrice() >= discountPrice;
  }

  Context apply(Context c) {
    c.discount(discountPrice);
    return c;
  }
}
```

이렇게 파이프라인 패턴을 적용하면 각 쿠폰을 다음 예제들과 같이 만들 수 있다.

### 예제: 가전제품 카테고리 10% 할인 쿠폰

쿠폰을 만드는 관리자는 미리 만들어진 여러 컴포넌트들 중에서 적절한 것을 선택해 드래그해서 순서대로 배치한 다음, 옮겨놓은 각 컴포넌트들에 참고값을 입력하면 된다.

![]( ./sample-pipeline1.svg )

이 쿠폰은 DB에 이렇게 저장하면 된다.

```js
{
  "id": "59C6880A-C360-4978-97BA-989A0F5DE85C",
  "name": "가전제품 10% 할인 쿠폰",
  "components": [
    {
      // 카테고리 체커
      "type":     "CategoryComponent",
      "category": [112]
    },
    {
      // 비율 할인 적용기
      "type": "RatioDiscountComponent",
      "ratio": 10,
      "maxDiscount": 10000,
    }
  ]
}
```

쿠폰을 불러올 때 `components` 리스트를 읽고 각 컴포넌트에 해당하는 인스턴스들의 리스트를 만들고 순서대로 `isPass`와 `apply` 메소드를 불러주기만 하면 된다.

```java
for (CouponComponent component : components) {
  if (component.isPass(context)) {
    context = component.apply(context);
  } else {
    context.setFail(component);
    break;
  }
}
```

이렇게 만들면 수십~수백개가 되는 `if`/`else`의 대부분이 사라지게 된다.

한편으로는 다음과 같은 장점도 있다.

- 쿠폰 관리자는 새로운 쿠폰을 구상하기보다 이미 존재하는 컴포넌트들을 조합해 만드는 방법을 1차적으로 고민하게 된다.
    - 컴포넌트 조합으로 해결이 안 되는 경우에만 개발 요청을 하면 된다.
- 새로운 쿠폰 기능이 필요할 때 개발자는 다음 두 가지를 만들면 된다.
    - 해당 기능만을 표현하는 컴포넌트 클래스 (백엔드, 프론트엔드)
- 관리자와 개발자 모두 위에서 아래로의 흐름으로 쿠폰의 로직을 이해할 수 있다.
    - 쿠폰 기준값을 DB에 저장하는 방식에서는 플로우 차트를 관리자에게 공개하지 않는다면(소스코드를 보여주지 않는다면) 각 값들이 어떤 순서대로, 어떤 우선순위를 갖고 적용되는지를 알 수 없는데, 파이프라인에서는 그냥 위에서 아래로 읽으면 된다.

- 각 컴포넌트 하나하나에 해당하는 테스트코드를 만들 수 있다.
- 컴포넌트 하나가 작고 간결하므로 하나하나를 이해하기 어렵지 않다.
    - 이해하기 어렵다 하더라도 if/else 가 수십개 있어 서로 영향을 주고받는 방식보다 사이드 이펙트가 적다.

물론 단점도 있다.

- 일단 만들어 배포한 컴포넌트는 지울 수 없다.

하지만 필요한 컴포넌트의 수는 많아봐야 20개 남짓할 것으로 생각한다.
내 예상을 뛰어넘는다 해도 40개 정도면 어지간한 온라인 쇼핑몰의 필요는 대부분 만족시킬 것이라 본다.

## 한 걸음 더 나아가는 방법: AST를 DB에 저장한다

여기에서 한 걸음 더 나아가, 아예 컴포넌트 없이 람다 함수 또는 AST를 DB에 함께 저장하는 방법도 있을 것이다.
이렇게 한다면 극도로 유연한 쿠폰 시스템을 만들 수 있을 것이고 개발자는 쿠폰 컴포넌트를 만들 필요조차 사라지게 된다.
그냥 `isPass`와 `apply`를 위한 DSL을 만들어서 관리자들에게 이 언어를 가르쳐주면 되기 때문이다.

하지만 과도한 방법일 거라 생각한다. 굳이 이렇게 할 필요는 없다.
일단 자유로운 코드가 가능하다는 점에서 보안 위험이 있고, 무한 루프가 가능한 코드를 관리자가 실수로 또는 고의로 만들어버리면 시스템 장애도 발생할 수 있다.

나는 `CouponComponent` 인터페이스를 사용하는 방법 정도로 충분하다고 생각한다.

