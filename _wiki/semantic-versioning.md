---
layout  : wiki
title   : 유의적 버전 (Semantic Versioning)
summary : 주버전.부버전.수버전
date    : 2020-01-12 18:33:50 +0900
updated : 2022-06-25 15:03:58 +0900
tag     : 
resource: 14/F57A95-5E15-43D7-8A80-4F8BF63E2E98
toc     : true
public  : true
parent  : [[index]]
latex   : true
---
* TOC
{:toc}

## 형식
### 기본 형식

$$
\text{ Major.Minor.Patch }
$$

Major, Minor, Patch를 각각 주버전, 부버전, 수버전이라고도 부른다.

* 기존 버전과 호환되지 않는다면 Major(주主) 버전을 올린다.
* 새로운 기능을 추가하면 Minor(부部) 버전을 올린다.
* 버그를 고쳤다면 Patch(수修) 버전을 올린다.

예
* `0.1.0`
* `2.9.15`
* `1.15.0`

> 시맨틱 버전은 '메이저.마이너.패치'의 형식을 띤다.
메이저 번호 변경은 구 버전을 지원하지 않는 수준의 API 변경이 있음을 의미한다.
마이너 번호 변경은 API가 진화했지만 기존 클라이언트를 여전히 지원하는 수준의 API 변경만 있음을 의미한다.
패치 번호 변경은 기존 기능의 버그를 고쳤음을 의미한다.
>
> 시맨틱 버저닝은 클라이언트가 어떤 API를 사용할 수 있을지를 알게 해준다.
[^JOS-236]

### - 식별자가 있는 형식

이 방식은 pre release 버전을 표기할 때 쓰곤 한다.

$$
\text{Major.Minor.Patch} \color{red}{-} \text{identifier}
$$

identifier는 `-`로 시작하고, `.`을 구분자로 쓴다.

예
* `1.0.0-alpha`
* `1.0.0-alpha.1`
* `1.0.0-0.3.7`
* `1.0.0-x.7.z.92`

### + 식별자가 있는 형식

이 방식은 빌드 메타데이터를 표기할 때 쓴다.

$$
\text{Major.Minor.Patch}-\text{identifier} \color{red}{+}\text{metadata}
$$

예
* `1.0.0-alpha+001`
* `1.0.0+20130313144700`
* `1.0.0-beta+exp.sha.5114f85`


## 기억해 둘 사항들

* 최초 개발 배포 버전을 `0.1.0`으로 한다.
* 자릿수를 맞추기 위해 `0`으로 시작하는 숫자를 쓰지 않도록 한다.
    * 예를 들어 `2.07.1`은 좋지 않다. `2.7.1`을 쓰도록 하자.
* 부모 버전이 오르면 자식 버전은 `0`으로 초기화한다.
    * Major 버전이 오르면 Minor와 Patch 버전은 `0`으로 초기화한다.
    * Minor 버전이 오르면 Patch 버전은 `0`으로 초기화한다.

## From: 구글 엔지니어는 이렇게 일한다

>
유의적 버전<sup>semantic versioning</sup>(SemVer)은 오늘날 의존성 네트워크를 관리하는 가장 대표적인 방법입니다.[^goo-11]
SemVer는 의존성의 버전을 표기하는 보편적인 방식입니다.
2.4.27이나 1.1.4처럼 숫자 세 개로 표현합니다.
세 숫자는 차례로 메이저<sup>major</sup>, 마이너<sup>minor</sup>, 패치<sup>patch</sup> 버전을 의미하며, 각각 다음과 같은 경우에 증가합니다.
>
> - 메이저: API가 변경되어 의존성을 이용하던 기존 코드를 깨뜨릴 수 있음
> - 마이너: 순수하게 기능 추가만 있음(기존 코드를 깨뜨리지 않음)
> - 패치: API에 영향을 주지 않는 내부 구현 개선과 버그 수정
>
버전 표기에 이렇게 의미를 담음으로써 SemVer에서는 'API가 호환되면서 더 최신 버전 같은 표현이 가능합니다.
예컨대 'libbase ≥ 1.5'라고 하면 1.5나 1.5.1 혹은 1.6 이상도 포괄합니다.
단 1.4.9는 1.5일 때 추가된 API가 없을 것이므로 안 됩니다.
2.x도 호환되지 않게 변경된 API가 있을 것이라서 안 됩니다.
메이저 버전이 달라지면 일반적으로 호환성이 크게 떨어집니다.
기존 기능들이 달라지거나 심지어 사라졌을 수도 있어서 이를 이용하던 모든 코드가 잠재적으로 문제를 겪을 수 있습니다.
의존 관계가 만들어질 때마다 명시적이든 묵시적이든 버전 요구사항이 존재합니다.
이를 가령 'liba는 libbase ≥ 1.5가 필요합니다' 혹은 'libb는 ≥ 1.4.7이 필요합니다'처럼 표현할 수 있습니다.
[^goo-566]

이처럼 요구사항 표현법을 정형화하면 의존성 네트워크

## 함께 읽기

* [[groupId-artifactId]]{Maven의 groupId 와 artifactId, 그리고 version}

## 참고문헌

* [JOS] 클라우드 네이티브 자바 / 조쉬 롱, 케니 바스타니 저/정윤진, 오명운, 장현희 역 / 책만 / 초판 1쇄 2018년 06월 29일
* [Semantic Versioning 2.0.0][semver-eng]
* [유의적 버전 2.0.0-ko2][semver-kor]
* 구글 엔지니어는 이렇게 일한다 / 타이터스 윈터스, 톰 맨쉬렉, 하이럼 라이트 저/개앞맵시 역 / 한빛미디어 / 초판 1쇄 발행 2022년 05월 10일 / 원제 : Software Engineering at Google


## 주석

[^JOS-236]: [JOS] 2.6장. 236쪽.
[^goo-11]: 구글 엔지니어는 이렇게 일한다. 21장. 565쪽. 원주: "엄밀히 따지면 유의적 버전은 소프트웨어의 버전을 메이저/마이너/패치 형태로 표현해 의미를 부여하는 관행 자체만을 말합니다. 의존성 사이의 호환 가능 버전을 표현하게끔 확대한 개념은 아니라는 말이죠. 소프트웨어 생태계에 따라 버전 체계를 조금씩 변형해 활용하기도 합니다. 그래서 유의적 버전이라고 하면 통상적으로 {메이저/마이너/패치 형태의 버전 번호 + 해당 체계}까지 포괄한 넓은 의미로 이해합니다."
[^goo-566]: 구글 엔지니어는 이렇게 일한다. 21장. 566쪽.

[semver-eng]: https://semver.org/
[semver-kor]: https://semver.org/lang/ko/
