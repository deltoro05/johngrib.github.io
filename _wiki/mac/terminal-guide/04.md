---
layout  : wiki
title   : macOS 초보를 위한 터미널 사용 가이드 - Week 04
summary : 작성중인 문서
date    : 2024-01-21 21:53:46 +0900
updated : 2024-01-28 15:55:33 +0900
tag     : 
resource: F4/5E14F8-0E28-44FE-9C80-63014FBE8851
toc     : true
public  : true
parent  : [[/mac/terminal-guide]]
latex   : false
---
* TOC
{:toc}

- 이전 문서: [[/mac/terminal-guide/03]]
- 다음 문서: /mac/terminal-guide/05

## grep 명령?

[[/cmd/grep]]은 1970년대 초부터 여태까지 수많은 사람들에 의해 사용되고 발전을 거듭해 온 유서깊은 프로그램입니다.
[[/cmd/grep]]을 처음 개발한 사람은 Ken Thompson입니다.

[[/people/brian-w-kernighan]]에 의하면 `grep`이라는 이름은 `ed`의 `g/re/p` 명령에서 왔다고 합니다.
(`ed`도 Ken Thompson이 개발한 프로그램입니다.)

이 가이드의 대상 플랫폼인 macOS에서는 오래된 버전의 BSD 유닉스에 들어있던 [[/cmd/grep]]이 설치되어 있습니다.
그래서 GNU [[/cmd/grep]]과는 몇 가지 옵션이나 기능, 성능 등에 차이가 있습니다.

[[/cmd/grep]]을 잘 쓰려면 GNU [[/cmd/grep]]과 BSD [[/cmd/grep]] 사이에서 서로 호환되는 옵션이 무엇인지를 알면 좋습니다.
그리고 3 종류의 정규식 문법(BRE, ERE, PCRE) 중 필수적으로 ERE, 좀 더 욕심내서 PCRE를 다룰 수 있으면 좋습니다.

## grep 기본 사용법 {#bsd-basic-usage}

GNU [[/cmd/grep]]에 대해서는 좀 미뤄두고 일단은 macOS에 기본으로 설치되어 있는 BSD [[/cmd/grep]]에 대해서만 기본적인 사용법을 익혀 봅시다.

먼저 `grep --version`으로 버전을 확인해 봅시다. 제 컴퓨터에서는 다음과 같이 나오네요.

```
$ grep --version
grep (BSD grep, GNU compatible) 2.6.0-FreeBSD
```

[[/cmd/grep]]의 기본 문법은 다음과 같습니다.

```
grep 옵션 검색패턴 파일이름1 파일이름2 파일이름3 ...
```

오른쪽에 파일 이름이 '수평 리스트'로 줄줄이 이어지는 것을 보고
[[/mac/terminal-guide/03#xargs]]{지난 주에 공부한} [[/cmd/xargs]]를 떠올릴 수 있다면 점점 터미널 사용에 익숙해지고 있다는 뜻입니다.

물론 떠올리지 못했어도 괜찮습니다.

UNIX 셸 명령들은 이렇게 마지막에 여러 파일의 이름을 나열하는 방식으로 돌아가는 것들이 많습니다.
그래서 자꾸 쓰다 보면 리스트가 뒤에 오는 방식에 익숙해집니다.

`/usr/share/dict/words` 파일은 컴퓨터에 기본적으로 내장되어 있는 영어사전입니다.

```
$ wc -l /usr/share/dict/words
235976 /usr/share/dict/words
```

단어가 235976개나 들어있네요. 이 파일을 대상으로 [[/cmd/grep]] 사용을 연습해 봅시다.

`study` 단어를 찾아보겠습니다.

```
$ grep study /usr/share/dict/words
afterstudy
forestudy
outstudy
overstudy
prestudy
restudy
study
understudy
```

여러 파일을 지정할 수 있었다는 것을 기억하고 계실 것입니다.
그러니 이번에는 2개의 파일을 지정해서 `study` 단어를 찾아보겠습니다.

```
$ grep study /usr/share/dict/words /usr/share/dict/web2
/usr/share/dict/words:afterstudy
/usr/share/dict/words:forestudy
/usr/share/dict/words:outstudy
/usr/share/dict/words:overstudy
/usr/share/dict/words:prestudy
/usr/share/dict/words:restudy
/usr/share/dict/words:study
/usr/share/dict/words:understudy
/usr/share/dict/web2:afterstudy
/usr/share/dict/web2:forestudy
/usr/share/dict/web2:outstudy
/usr/share/dict/web2:overstudy
/usr/share/dict/web2:prestudy
/usr/share/dict/web2:restudy
/usr/share/dict/web2:study
/usr/share/dict/web2:understudy
```

파일이 두 개가 되니 검색 결과에서 어떤 파일에서 찾았는지도 함께 표시되는 것을 볼 수 있습니다.
다음과 같은 형식입니다.

```
찾은파일이름:찾은단어
```

물론 [[/cmd/grep]]이 표준입력(`0`)으로 들어오는 텍스트를 읽어서 처리하게 하고 싶다면 단순하게 파이프 `|`를 사용하면 됩니다.

```
$ seq 30 | grep 4
4
14
24
```

- `seq 30`: 1부터 30까지를 출력
- `grep 4`: 4가 포함되어 있는 줄만 출력

### -o 옵션 {#o-option}

`-o` 옵션을 주면 매치된 문자열만 출력해 줍니다.

```
$ seq 3000 | grep 444
444
1444
2444

$ seq 3000 | grep 444 -o
444
444
444
```

`-o` 옵션이 없을 때에는 1부터 3000까지의 숫자 중에서 444와 매치된 '줄'을 출력했습니다.

그러나 `-o` 옵션을 주면 444와 매치된 '문자열'만을 출력합니다.

### -v 옵션

`-v` 옵션을 주면 매치되지 않은 줄만 출력합니다.

```
seq 100 | grep -v 2
```

- `seq 100`: 1부터 100까지를 출력
- `grep -v 2`: 2가 포함되지 않은 줄만 출력

명령을 실행해보면 출력 결과가 꽤 많을 겁니다.
모아서 보기 쉽게 [[/cmd/xargs]]를 써서 10개씩 한 줄로 모아서 출력해 봅시다.

```
$ seq 100 | grep -v 2 | xargs -n 10
1 3 4 5 6 7 8 9 10 11
13 14 15 16 17 18 19 30 31 33
34 35 36 37 38 39 40 41 43 44
45 46 47 48 49 50 51 53 54 55
56 57 58 59 60 61 63 64 65 66
67 68 69 70 71 73 74 75 76 77
78 79 80 81 83 84 85 86 87 88
89 90 91 93 94 95 96 97 98 99
100
```

1 ~ 100 중에서 2가 포함된 것들만 빼고 모두 출력된 것 같습니다.

[[/cmd/grep]]을 한 번 더 써서 이 결과를 확인할 수 있을 겁니다.

```
$ seq 100 | grep -v 2 | grep 2 | wc -l
0
```

- `seq 100`: 1부터 100까지를 출력
- `grep -v 2`: 2가 포함되지 않은 줄만 출력
- `grep 2`: 2가 포함된 줄만 출력
- `wc -l`: 줄 수를 세어서 출력

사실 `grep -v 2`와 `grep 2`는 서로 논리적으로 정반대의 결과를 출력하기 때문에 이 결과는 당연한 것이기도 합니다.

### --color 옵션

`--color` 옵션을 주면 매치된 부분에 색을 입혀서 출력해 줍니다.

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>$ seq 50 | grep 6 --color
<span class="red">6</span>
1<span class="red">6</span>
2<span class="red">6</span>
3<span class="red">6</span>
4<span class="red">6</span>
</code></pre></div></div>

>
**alias 지정하기**
>
[[/cmd/grep]] 명령을 입력할 때마다 매번 `--color` 옵션을 주기는 귀찮습니다.
그러니 그냥 `grep`을 실행해도 `--color` 옵션이 적용되도록 `alias`를 설정해 두면 편리합니다.
>
> ```bash
> alias grep='grep --color=auto'
> ```
>
이렇게 한번 입력해두면 해당 터미널을 종료할 때까지는 `grep`을 실행할 때마다 `grep --color=auto`가 실행되는 것과 똑같이 작동합니다.
>
다음 터미널 세션에서도 사용하고 싶다면 
`~/.bash_profile`이나 `~/.bashrc` 또는 `~/.zshrc`에 해당 `alias`를 설정해 두면 됩니다.
{:style="background-color: #ecf1e8;"}


### -R 옵션

만약 하위의 모든 디렉토리에 대해 검색을 하고 싶다면 `-R` 옵션을 사용하면 됩니다.

```
grep -R 'Thompson' ~/johngrib.github.io
```

- `~/johngrib.github.io` 디렉토리부터 하위의 모든 디렉토리에 대해 'Thompson'을 검색

한편 `-R`은 파일이나 경로를 지정하지 않아도 알아서 현재 경로를 기준으로 탐색을 시작합니다.
그래서 다음과 같이 해도 됩니다.

```
cd ~/johngrib.github.io
grep -R 'Thompson'
```

- 현재 경로 하위의 모든 디렉토리에 대해 'Thompson'을 검색

![]( /resource/F4/5E14F8-0E28-44FE-9C80-63014FBE8851/grep-rr-thompson.jpg )

지금까지의 [[/cmd/grep]] 실행 결과는 검색된 라인이 출력되는 방식이었습니다.
그런데 `-R` 옵션을 사용하면 위의 스크린샷과 같이 `파일명:검색결과` 형식으로 출력됩니다.

하지만 긴 파일을 대상으로 검색을 할 때에는 파일명만으로는 검색 결과를 활용하기 어렵습니다.

그래서 `-R`을 사용할 때에는 `-n` 옵션을 함께 사용하는 경우가 많습니다.


### -n 옵션

`-n` 옵션을 주면 검색된 라인의 줄 번호를 함께 출력합니다.

```
$ printf "가위\n바위\n보\n" | grep -n 바
2:바위

$ printf "가위\n바위\n보\n" | grep -n 위
1:가위
2:바위
```

`-R` 옵션과 함께 사용하면 `파일명:줄번호:검색결과` 형식으로 출력되기 때문에 검색 결과를 보고, 파일을 열어서 해당 위치로 찾아가기가 쉽습니다.

```
grep --color -n -R 'Thompson' ~/johngrib.github.io
```

![]( /resource/F4/5E14F8-0E28-44FE-9C80-63014FBE8851/grep-n-rr-thompson.jpg )

이와 같은 `파일명:줄번호` 형식은 파일의 특정한 위치를 표시할 필요가 있는 경우에 UNIX 계열 명령어들이 공통으로 사용하는 형식이므로 기억해두면 좋습니다.


>
**(아직은 좀 어려울 수 있는) 팁**
>
터미널에서 작동하는 것을 기본으로 두는 [[/vim]] 에디터에서도 `파일명:줄번호` 형식을 중요하게 사용하고 있습니다.
그래서 `파일명:줄번호` 형식의 문자열 위에 커서를 두고 `gF`를 입력하면 바로 해당 파일의 해당 라인으로 이동할 수 있습니다.
>
그래서 다음과 같은 활용이 가능해집니다.
>
> ```
> grep -n -R 'Thompson' \
>   ~/johngrib.github.io/_wiki > grep-result \
>   && vim grep-result
> ```
>
> - `grep -n -R 'Thompson' 경로 > grep-result`: 지정한 경로의 모든 하위 디렉토리에서 'Thompson'을 검색해서 검색 결과를 `grep-result` 파일에 저장한다.
> - `&&` - 이전 명령이 성공하면 다음 명령을 실행한다.
> - `vim grep-result`: `grep-result` 파일을 vim으로 열어서 검색 결과를 확인한다.
>
> 이렇게 vim에서 검색결과 파일을 열게 되면 스크롤을 하면서 검색결과를 보고 `gF`를 사용해 각 파일의 해당 라인들로 바로 이동할 수 있습니다.
> (`gf`는 파일을 열어주기만 하고, `gF`는 파일을 연 다음 해당 라인으로 바로 이동해줍니다.)
>
> <video controls autoplay loop><source src=" /resource/F4/5E14F8-0E28-44FE-9C80-63014FBE8851/vim-gf.mp4 " type="video/mp4"></video>
>
> 물론 파일을 생성하는 것이 귀찮다면 [[/cmd/grep]]의 표준출력(`1`)을 바로 [[/vim]]으로 넘겨주는 방법도 있습니다.
>
> ```
> grep --color -n -R 'Thompson' ~/johngrib.github.io | vim -
> ```
>
{:style="background-color: #ecf1e8;"}


### find 명령과의 조합

[[/cmd/grep]]은 수많은 다른 명령들과 조합해서 사용할 수 있습니다.

이번에는 앞에서 공부했던 [[/cmd/find]]와 조합해서 사용해 봅시다.
`-exec` 옵션을 사용하면 찾아낸 파일들에 대해 일일이 실행할 수 있겠죠.

```
find ~/johngrib.github.io -name '*.md' -exec grep 'Thompson' {} \;
```

- `find ~/johngrib.github.io`: johngrib.github.io 디렉토리부터 시작해서 하위 디렉토리까지 모두 탐색
- `-name '*.md'`: 확장자가 `.md`인 파일만 탐색
- `-exec grep 'Thompson' {} \;`: 찾은 파일들에 대해 'Thompson'을 검색

좀 더 빠르게 실행하고 싶다면 역시 [[/mac/terminal-guide/03#xargs-find]]{이전에 공부했던 xargs를 사용하면} 되겠죠.

```
find ~/johngrib.github.io -name '*.md' | xargs grep 'Thompson'
```

### -B 와 -A 옵션

`-B`(before)와 `-A`(after) 옵션을 사용하면 찾은 라인의 앞/뒤로 몇 줄을 더 출력할 수 있습니다.

예를 들어 `-B3`은 찾은 곳의 아래로 3줄을 더 보여주고, `-A2`는 찾은 곳의 위로 2줄을 더 보여줍니다.

```
grep -A3 -B2 -R Architectural
```

![]( /resource/F4/5E14F8-0E28-44FE-9C80-63014FBE8851/grep-a-b-r.jpg )

위 아래로 몇 줄을 더 보여주므로 각 검색결과 경계를 구분해주기 위해 `--` 두 글자만 있는 라인이 중간중간에 추가되어 있습니다.

여기에 `-n` 옵션을 추가하면 줄번호도 같이 표시되므로 정말로 아래로 3줄, 위로 2줄을 더 보여주는지 확인할 수 있습니다.

```
grep -A3 -B2 -n -R Architectural
```

![]( /resource/F4/5E14F8-0E28-44FE-9C80-63014FBE8851/grep-a-b-n-r.jpg )

보통 프로그래밍 프로젝트에서 함수 이름 등으로 검색할 때에는 `-B5` 정도로 위로 5줄을 더 보여주는 것이 편리합니다.
그렇게 하면 그 함수 시그니처 위의 주석도 같이 볼 수 있는 결과가 나오기 때문입니다.

## grep에서 더 나아가기

### GNU grep 설치하고 사용하기

앞에서 언급한 바와 같이 [[/cmd/grep]]은 역사가 오래된 프로그램입니다.
게다가 하필 macOS는 오래된 버전의 BSD grep을 제공하고 있기 때문에 GNU grep에 비해 몇 가지 짜증나는 점들이 있습니다.

- GNU grep이 macOS에 설치된 오래된 버전의 BSD grep보다 거의 모든 점이 뛰어납니다.
- macOS의 grep은 PCRE(Perl Compatible Regular Expression)을 지원하지 않습니다.
- GNU grep이 macOS에 설치된 grep보다 훨씬 빠릅니다.

이번에는 GNU grep을 설치해 봅시다. 다음 명령을 실행하면 됩니다.

```
brew install grep
```

그런데 설치가 끝난다고 해서 곧바로 GNU grep을 사용할 수 있는 것은 아닙니다.
macOS에 이미 기본으로 설치된 grep과 충돌을 피하기 위해 GNU grep을 `ggrep`라는 이름으로 설치하기 때문입니다.

따라서 GNU grep을 사용하려면 `ggrep`이라는 이름으로 실행하거나 아니면 `grep`을 `ggrep`으로 aliasing해야 합니다.

이 가이드에서는 `alias`를 사용하지 않고 그냥 `ggrep`이라는 이름을 사용할 것입니다.
그러니 이제부터 `ggrep` 명령을 사용하면 GNU grep을 실행하는 것이라고 생각하시면 됩니다.

설치가 끝났으니 이제 간단하게 macOS에 설치된 grep과 GNU grep의 속도를 비교해 봅시다.

```
$ find . -type f | wc -l
13059
```

파일이 13,059 개 있는 디렉토리가 테스트 대상입니다

```
$ time grep -R test >/dev/null 2>&1

real    0m13.522s
user    0m12.033s
sys     0m0.458s

$ time ggrep -R test >/dev/null 2>&1

real    0m0.584s
user    0m0.294s
sys     0m0.267s
```

13,059개의 파일을 대상으로 `test`라는 단어를 검색하는데, macOS에 설치된 grep은 13.522초가 걸렸습니다.
그런데GNU grep은 0.584초 밖에 걸리지 않았습니다.

검색 대상 파일의 수가 많으면 많을수록 이 차이는 더욱 커질 것입니다.

인생은 짧으니까 GNU grep을 사용하는 것이 더 나은 결정일 수 있습니다.

### BRE, ERE, PCRE {#bre-ere-pcre}

IEEE POSIX 표준에서는 정규식을 다음과 같이 구분합니다.[^wikipedia-regex-standards]
- SRE(Simple Regular Expression)
- BRE(Basic Regular Expression)
- ERE(Extended Regular Expression)

이들 중 SRE는 deprecated 되었고 BRE는 여러모로 불편하기 때문에, 아주 단순한 패턴이 아니라면 실제로 [[/cmd/grep]]을 사용할 때에는 주로 ERE를 쓰게 됩니다.

BRE의 이름을 보면 "Basic"인데 왜 불편하다는 걸까 하는 생각을 할 수 있습니다.
그런데 BRE는 괄호나 수량자 등등에 `\`를 붙여 이스케이핑해줘야 하기 때문에 조금이라도 덜 단순한 정규 표현식을 쓰려 한다면 무지 귀찮습니다.


| BRE | `\?` | `\+` | `\{` | `\}` | `\(` | `\)` | `\|` |
| ERE | `?`  | `+`  | `{`  | `}`  | `(`  | `)`  | `|` |

PCRE는 Perl 호환 정규식으로, 대부분의 고급 정규식 기능은 PCRE와 관련된 것이기도 합니다.

많은 수의 프로그래밍 언어의 빌트인 라이브러리에 포함되는 정규식 구현체들은 PCRE 스펙을 참고하고 있습니다.
다만 PCRE는 기능이 매우 많아서 대부분의 PCRE를 참고한 정규식 구현체들은 모든 기능을 구현하지 않기도 합니다.

하지만 그럼에도 불구하고 상식으로 BRE를 알아둘 필요는 있는데 옵션 없이 사용하는 [[/cmd/grep]], [[/cmd/sed]] 등이 BRE로 돌아가기 때문입니다.

[[/cmd/grep]], [[/cmd/sed]]에서 BRE가 아니라 ERE를 사용하려면 `-E` 옵션을 사용하면 됩니다.


### 몇 가지 정규식 사용 도구 비교 {#comparison-of-regex-tools}

다음은 macOS에서 정규식을 사용하는 몇 가지 도구들을 제 마음대로 비교/정리해 본 것입니다.

<div id="table-grep-alternatives"></div>
- th
    - 
    - 설치 방법
    - BRE
    - ERE
    - PCRE
    - 특징
- td
    - [[/cmd/grep]]{macOS 빌트인 grep}
    - 설치되어 있음
    - default
    - `-E`
    - 지원안함
    - 
        - GNU grep에 비해 엄청나게 느림
        - 보통 macOS를 쓰는 회사라면 다같이 쓰는 셸 스크립트에서 주로 이걸 사용함
- td
    - GNU grep
    - 
        - `brew install grep`
        - `ggrep`으로 실행
    - default
    - `-E`
    - `-P`
    - 
        - macOS에 설치되어 있는 grep보다 많이 빠름
        - 귀찮게 설치해야 한다는 걸 빼고는 macOS grep보다 모든 점이 좋음
- td
    - macOS 빌트인 egrep
    - 설치되어 있음
    - `-G`
    - default
    - 지원안함
    - `-E`를 안 적어도 되어서 macOS grep보다 덜 귀찮음
- td
    - GNU egrep
    - 
        - GNU grep과 함께 설치됨
        - `gegrep`으로 실행
    - `-G`
    - default
    - `-P`
    - deprecated. 실행하면 GNU grep을 사용하라고 경고 메시지가 나옴
- td
    - [[/cmd/sed]]{macOS 빌트인 sed}
    - 설치되어 있음
    - default
    - `-E`
    - 지원안함
    - 기능 지원보다 빠른 속도가 더 중요해서 PCRE 지원을 안함
- td
    - [[/perl-one-liner]]{perl 5}
    - 설치되어 있음
    - 지원안함
    - 지원안함
    - default[^pcre]
    - 시대를 풍미한 프로그래밍 언어
- td
    - [[/cmd/ag]]
    - `brew install ag`
    - 지원안함
    - 지원안함
    - default
    - `-R` 옵션이 기본. 거의 매일 사용함.
- td
    - [[/cmd/rg]]{rg}
    - `brew install rg`
    - 
    - 
    - `-P`
    - 
        - [[/cmd/ag]]보다 빠름.
        - `-R` 옵션이 기본.
{:class="table-generate" data-target-id="table-grep-alternatives"}



작성중입니다...

## 주석

[^pcre]: PCRE가 Perl Compatible Regular Expression의 약자이다. 즉 Perl을 쓰면 PCRE가 기본이다.
[^wikipedia-regex-standards]: [Regular expression (wikipedia.org) # Standards](https://en.wikipedia.org/wiki/Regular_expression#Standards )

