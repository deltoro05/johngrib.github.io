---
layout  : wiki
title   : macOS 초보를 위한 터미널 사용 가이드 - Week 02
summary : 작성중인 문서
date    : 2024-01-15 23:39:16 +0900
updated : 2024-01-20 19:17:50 +0900
tag     : 
resource: D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540
toc     : true
public  : true
parent  : [[/mac/terminal-guide]]
latex   : false
---
* TOC
{:toc}

## file descriptor 0, 1, 2 {#file-descriptor}

이번에는 셸 명령에서 중요한 0, 1, 2 를 공부해 보도록 하겠습니다.

우리가 명령을 입력해 실행하면, 프로세스가 생성됩니다.
그리고 프로세스는 기본적으로 3개의 file descriptor를 갖습니다.

- 0 : stdin, 표준입력
- 1 : stdout, 표준출력
- 2 : stderr, 표준에러 (표준에러 출력)

### 예제와 그림 {#example-and-picture}

이해를 돕기 위해 간단한 명령 중 하나인 [[/cmd/echo]]를 실행해 봅시다.

```
$ echo hello
hello
```

이걸 그림으로 표현해보겠습니다.
공식적인 유형의 그림은 아니고 제가 좋아하는 방식으로 마음대로 표현한 그림입니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/hello-process.svg )

- `echo`의 프로세스가 생성됐습니다.
- `echo`는 명령줄 인자로 `hello`를 받았습니다.
- 표준입력(`0`)으로 받은 것은 없습니다.
- 표준출력(`1`)으로 `hello`를 내보냈습니다.
    - 기본적으로 표준출력으로 내보내면 터미널 화면에 표시가 됩니다.
- 표준에러(`2`)로는 아무것도 내보내지 않았습니다.
    - 실행과정에서 에러가 없었기 때문입니다.

이제 이 여기에 [[/cmd/tr]]를 연결해 봅시다.

다음은 [[/cmd/echo]]의 출력을 [[/cmd/tr]]로 전달하는 파이프라인 명령입니다.

```
$ echo hello | tr l r
herro
```

- `echo hello`: `hello`를 출력.
- `tr l r`: `echo`의 출력인 `hello`를 받아서 `l`을 `r`로 바꾼 결과를 출력.

이것도 그림으로 그려보겠습니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/hello-tr-process.svg )

파이프 (`|`) 를 통해 `echo`의 출력이 `tr`의 입력으로 전달되는 것이 눈에 보일 것입니다.

파이프는 이전 프로세스의 표준출력(`1`)을 다음 프로세스의 표준입력(`0`)으로 연결해 주겠다고 선언하는 것입니다.

그래서 [[/cmd/tr]]{tr}은 [[/cmd/echo]]{echo}의 출력인 `hello`를 받아서 `l`을 `r`로 바꾼 결과인 `herro`를 출력하게 되었습니다.

그렇다면 이번에는 결과를 터미널 화면이 아니라 파일로 리다이렉팅 해 봅시다.

아래의 명령 파이프라인과 같이 `echo | tr`의 출력을 `hello.txt` 파일로 보내면, `hello.txt` 파일에는 `herro`가 저장될 것입니다.

```
$ echo hello | tr l r > hello.txt

$ cat hello.txt
herro
```

다음은 이 과정을 그림으로 표현한 것입니다. [[/cmd/tr]]{tr}의 표준출력(`1`)이 `hello.txt` 파일로 리다이렉팅 되는 것에 주목합시다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/hello-tr-file-process.svg )

### Java의 System.in, System.out, System.err {#java-system-class}

이 가이드 문서를 통해 0, 1, 2 채널을 처음 알게 된 분들이 있다면, 생소하면서 신기한 느낌을 받고 있을지도 모르겠습니다.

그러나 평소 널리 알려져 있는 프로그래밍 언어를 통해 프로그래밍을 하고 있었다면 자신도 모르는 사이에 이들을 사용하고 있었을 것입니다.

예를 들어 [[/java]]의 `java.lang.System` 클래스를 열어보면 `in`, `out`, `err`이 있는데요, 이것들이 0, 1, 2 입니다.

- [open jdk(jdk-23+6)의 System.in](https://github.com/openjdk/jdk/blob/ff8cc268fdaaf85299c94088a226b73e7eaf6bdb/src/java.base/share/classes/java/lang/System.java#L128-L140 ): 표준입력(`0`)
    - 첫째줄의 `The "standard" input stream.` 이라는 주석이 표준입력(`0`)을 설명하고 있습니다.

```java
/**
 * The "standard" input stream. This stream is already
 * open and ready to supply input data. Typically this stream
 * corresponds to keyboard input or another input source specified by
 * the host environment or user. In case this stream is wrapped
 * in a {@link java.io.InputStreamReader}, {@link Console#charset()}
 * should be used for the charset, or consider using
 * {@link Console#reader()}.
 *
 * @see Console#charset()
 * @see Console#reader()
 */
public static final InputStream in = null;
```

- [open jdk(jdk-23+6)의 System.out](https://github.com/openjdk/jdk/blob/ff8cc268fdaaf85299c94088a226b73e7eaf6bdb/src/java.base/share/classes/java/lang/System.java#L142-L172 ): 표준출력(`1`)
    - 첫째줄의 `The "standard" output stream.` 이라는 주석이 표준출력(`1`)을 설명하고 있습니다.
    - 예를 들어 `System.out.print("str")`은 표준출력(`1`)으로 `str`을 보내는 것입니다.

```java
/**
 * The "standard" output stream. This stream is already
 * open and ready to accept output data. Typically this stream
 * corresponds to display output or another output destination
 * specified by the host environment or user. The encoding used
 * in the conversion from characters to bytes is equivalent to
 * {@link Console#charset()} if the {@code Console} exists,
 * <a href="#stdout.encoding">stdout.encoding</a> otherwise.
 * <p>
 * For simple stand-alone Java applications, a typical way to write
 * a line of output data is:
 * <blockquote><pre>
 *     System.out.println(data)
 * </pre></blockquote>
 * <p>
 * See the {@code println} methods in class {@code PrintStream}.
 *
 * @see     java.io.PrintStream#println()
 * @see     java.io.PrintStream#println(boolean)
 * @see     java.io.PrintStream#println(char)
 * @see     java.io.PrintStream#println(char[])
 * @see     java.io.PrintStream#println(double)
 * @see     java.io.PrintStream#println(float)
 * @see     java.io.PrintStream#println(int)
 * @see     java.io.PrintStream#println(long)
 * @see     java.io.PrintStream#println(java.lang.Object)
 * @see     java.io.PrintStream#println(java.lang.String)
 * @see     Console#charset()
 * @see     <a href="#stdout.encoding">stdout.encoding</a>
 */
public static final PrintStream out = null;
```

- [open jdk(jdk-23+6)의 System.err](https://github.com/openjdk/jdk/blob/ff8cc268fdaaf85299c94088a226b73e7eaf6bdb/src/java.base/share/classes/java/lang/System.java#L174-L192 )
    - 첫째줄의 `The "standard" error output stream. This stream is already` 이라는 주석이 표준에러출력(`2`)을 설명하고 있습니다.

```java
/**
 * The "standard" error output stream. This stream is already
 * open and ready to accept output data.
 * <p>
 * Typically this stream corresponds to display output or another
 * output destination specified by the host environment or user. By
 * convention, this output stream is used to display error messages
 * or other information that should come to the immediate attention
 * of a user even if the principal output stream, the value of the
 * variable {@code out}, has been redirected to a file or other
 * destination that is typically not continuously monitored.
 * The encoding used in the conversion from characters to bytes is
 * equivalent to {@link Console#charset()} if the {@code Console}
 * exists, <a href="#stderr.encoding">stderr.encoding</a> otherwise.
 *
 * @see     Console#charset()
 * @see     <a href="#stderr.encoding">stderr.encoding</a>
 */
public static final PrintStream err = null;
```

### /dev/fd {#dev-fd}

흥미로운 사실은 이런 0, 1, 2 가 내 컴퓨터의 하드디스크에 특수한 파일로 존재한다는 것입니다.

[[/cmd/ls#option-l]]{ls -l} 명령으로 [[/cmd/dev/fd]] 디렉토리를 조사해 보면 0, 1, 2 라는 이름의 파일을 확인할 수 있습니다.
(3 이상은 운영체제나 다른 프로세스가 사용하고 있는 것이니 지금은 신경쓰지 않아도 됩니다.)

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/dev-fd-012.jpg )

- 가장 왼쪽을 보면 `c`라고 되어 있는데, 이것은 바이트 문자를 처리하는 특수 디바이스를 의미합니다.
    - 즉 0, 1, 2 는 특수 디바이스입니다.

한편 0, 1, 2 가 의미하는 바가 표준입력, 표준출력, 표준에러이다 보니 이를 의미하는 이름으로 연결된 것도 있습니다.

`ls -l /dev/std*` 명령으로 확인해 보면 다음과 같이 확인할 수 있습니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/ls-l-dev-std.jpg )

0, 1, 2 가 각각 `/dev/stdin`, `/dev/stdout`, `/dev/stderr` 로 연결되어 있습니다.

- 가장 왼쪽의 `l`은 이 파일들이 심볼릭 링크라는 것을 의미합니다.
- 심볼릭 링크에 대해서는 다음에 설명하고, 여기에서는 넘어가겠습니다.


## 출력 텍스트 스트림을 연결하기 {#output-text-stream}

이번에는 다음과 같이 [[/cmd/wc]]를 사용해서 3개의 파일의 줄 수를 조사해 봅시다.
참고로 `asdf`라는 파일은 존재하지 않는 파일인데, 에러 메시지를 확인하기 위해 일부러 집어넣었습니다.

```
$ wc -l  ~/.bashrc  asdf  ~/.bash_profile

     156 /Users/johngrib/.bashrc
wc: asdf: open: No such file or directory
      52 /Users/johngrib/.bash_profile
     208 total
```

- 출력 결과의 둘째 줄을 보면 `No such file or directory` 라는 메시지가 출력되었습니다.
    - asdf라는 파일이 없기 때문입니다.
    - 이 둘째 줄은 에러 메시지이므로, 표준에러(`2`)로 출력되었을 것으로 추측할 수 있을 것입니다.

이번에 실행한 명령도 그림으로 표현해 보겠습니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/wc-l-2.svg )

- [[/cmd/wc]]{wc 프로세스}는
    - 명령줄 인자로 `-l, ~/.bashrc, asdf, ~/.bash_profile` 를 받았습니다.
    - `~/.bashrc` 파일과 `~/.bash_profile` 파일을 읽고, 줄 수를 카운트한 결과를 표준출력(`1`)으로 내보냈습니다.
    - 디스크에서 찾지 못한 파일인 `asdf`에 대한 에러 메시지를 표준에러(`2`)로 내보냈습니다.

### 2번 채널로 리다이렉팅하는 `2>` {#redirecting-2}

위의 그림과 같이 잘 작동하는지 확인하기 위해 2번 채널로의 출력을 파일로 리다이렉팅해 봅시다.

```
$ wc -l  ~/.bashrc  asdf  ~/.bash_profile 2> result2.txt
     156 /Users/johngrib/.bashrc
      52 /Users/johngrib/.bash_profile
     208 total
```

1번 채널은 터미널 화면으로 잘 출력됐고, 2번 채널은 `result2.txt` 파일로 출력됐기 때문에 `asdf` 파일이 없다는 내용은 화면에 출력되지 않았습니다.

그리고 `result2.txt` 파일을 확인해 보면 에러 메시지가 잘 저장되어 있습니다.

```
$ cat result2.txt
wc: asdf: open: No such file or directory
```

### 1번 채널로 리다이렉팅하는 `>` {#redirecting-1}

이번에는 1번 채널도 파일로 리다이렉팅해 봅시다.

```
$ wc -l  ~/.bashrc  asdf  ~/.bash_profile > result1.txt 2> result2.txt
```

두 출력이 모두 파일로 리다이렉팅됐기 때문에 화면에는 아무것도 출력되지 않았습니다.

명령이 이제 조금씩 길어지기 시작했습니다.
명령을 여러 줄로 표현하려면 `\`를 사용하면 됩니다.

```
wc -l  ~/.bashrc  asdf  ~/.bash_profile \
  > result1.txt \
  2> result2.txt
```

이제 `result1.txt` 파일과 `result2.txt` 파일을 확인해 봅시다.

```
$ cat result1.txt
 156 /Users/johngrib/.bashrc
  52 /Users/johngrib/.bash_profile
 208 total

$ cat result2.txt
wc: asdf: No such file or directory
```

### 2번 채널을 1번 채널로 리다이렉팅하는 `2>&1` {#redirecting-2-1}

두 채널의 출력을 하나로 모아보는 것이 필요한 경우도 있습니다.

`2>&1` 을 사용하면 2번 채널의 출력을 1번 채널로 리다이렉팅할 수 있습니다(단, `2>&1`을 쓸 때 띄어쓰기를 하면 안됩니다).

```
$ wc -l  ~/.bashrc  asdf  ~/.bash_profile 2>&1
     156 /Users/johngrib/.bashrc
wc: asdf: open: No such file or directory
      52 /Users/johngrib/.bash_profile
     208 total
```

`2>&1`을 실행한 결과를 보면 `2>&1`을 쓰지 않았을 때와 똑같아 보입니다.
그러나 실제로는 차이가 좀 있습니다.

그림으로 그려보겠습니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/wc-l-2-to-1.svg )

이런 식으로 파이프라인을 구성했을 때 1번 채널을 파일로 리다이렉팅해주면 하나의 파일에 표준출력과 표준에러를 모두 저장할 수 있습니다.

```bash
 # 2번 채널을 1번 채널로 리다이렉팅하고, 1번 채널을 파일로 리다이렉팅
wc -l  ~/.bashrc  asdf  ~/.bash_profile > result.txt 2>&1

 # 이렇게 해도 됩니다
 #                                      ↓ 띄어쓰기 없이 쓰면 덜 헷갈립니다
wc -l  ~/.bashrc  asdf  ~/.bash_profile >result.txt 2>&1

 # 이렇게 해도 됩니다
 #                                      ↓ > 대신 1> 을 써도 됩니다
wc -l  ~/.bashrc  asdf  ~/.bash_profile 1>result.txt 2>&1
```

결과는 예상한 대로 파일 하나에 모든 출력이 모여 있습니다.

```
$ cat result.txt
wc: asdf: open: No such file or directory
     156 /Users/johngrib/.bashrc
      52 /Users/johngrib/.bash_profile
     208 total
```

### 흔한 패턴: `2>/dev/null` {#redirecting-2-dev-null}

짧고 간단한 명령 파이프라인을 구성해 실행할 때에는 에러 메시지가 화면에 출력되어도 크게 문제가 되지 않습니다.
오히려 에러 메시지 덕분에 문제 상황을 빨리 파악할 수 있기 때문에 에러 메시지를 화면에 출력하는 것이 좋습니다.

그러나 길고 복잡한 셸 스크립트 파일을 작성하거나 몇몇 중요하지 않은 에러 메시지가 반복적으로 출력되는 경우에 의도적으로 에러 메시지를 숨겨야 할 수도 있습니다.

이런 경우에 생각하기 쉬운 방법은 2번 채널을 특정한 로그 파일로 리다이렉팅하는 것일 겁니다.

```
wc -l  ~/.bashrc  asdf  ~/.bash_profile 2> error.log
```

이러면 에러 메시지가 `error.log` 파일에 저장되기 때문에 화면에는 에러 메시지가 출력되지 않으며, 나중에 `error.log` 파일을 확인해 보는 것으로 에러 메시지를 확인할 수 있습니다.

그런데 만약 에러 로그를 아예 확인할 필요가 없고, 파일을 생성할 필요도 없는 경우라면
2번 출력을 "null 장치"로 리다이렉팅하는 것이 일반적입니다.

```
$ wc -l  ~/.bashrc  asdf  ~/.bash_profile 2>/dev/null
     156 /Users/johngrib/.bashrc
      52 /Users/johngrib/.bash_profile
     208 total
```

드디어 `/dev/null`이 등장했습니다.

`/dev/null`은 null device라는 가상의 장치로, 입력되는 모든 값을 그냥 버리기만 합니다.

이야기가 나온 김에 매뉴얼도 읽어봅시다. (`/dev/null`의 man 페이지를 보려면 4번 섹션을 지정해 줘야 합니다.)

```
man 4 null
```

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/man-4-dev-null.jpg )

### /dev 디렉토리에 대하여 {#whatis-dev}

`/dev/fd`와 `/dev/null`이 들어있는 `/dev` 디렉토리는 장치 파일을 모아둔 곳입니다.

`/dev`는 device를 의미합니다(develop이 아닙니다).

`/dev`에는 file descriptor도 있고...

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/dev-ls-fd.jpg )

터미널 디바이스([[/cmd/tty]]{tty}: teletype 시절의 레거시가 아직 이 이름으로 남아있습니다)도 있고...

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/dev-ls-tty.jpg )

디스크도 있습니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/dev-ls-disk.jpg )

USB 메모리 스틱을 macOS 컴퓨터에 연결하면 디스크 장치 파일이 이 목록에 추가되니 한번 확인해 보세요.

## tee 사용법 {#tee}

[[/cmd/tee]]는 자신의 0번 채널로 들어오는 입력을 1번 채널로 '그대로' 출력하면서, 동시에 명령줄 인자로 받은 파일로도 출력해줍니다.

[[/cmd/tee]]의 이름은 T자 모양의 연결파이프에서 유래했습니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/tee.jpg )
[^tee-image]

이제 [[/cmd/tee]]를 사용해 봅시다.

[[/mac/terminal-guide/00#one-line-rsp]]{Week 00의 한줄짜리 가위바위보}에서 사용했던 명령을 다시 살펴봅시다.

```
printf "가위\n바위\n보\n" \
  | sort -R \
  | tail -1
```

이 명령 파이프라인을 실행하면 랜덤하게 가위바위보 중 하나가 출력됩니다.

그런데 이 명령의 중간 지점에서 생성되는 '랜덤 정렬된 결과'가 궁금하다면 어떻게 해야 할까요?

이럴 때 [[/cmd/tee]]를 사용하면 됩니다.

```
$ printf "가위\n바위\n보\n" | sort -R | tee sort-result.txt | tail -1
보

$ cat sort-result.txt
가위
바위
보
```

명령이 실행된 이후 출력된 결과는 [[/cmd/tee]]를 끼워넣기 전과 똑같아 보이지만,
[[/cmd/sort#option-random]]{sort -R}의 결과를 [[/cmd/tee]]{tee}가 `sort-result.txt` 파일로 빼돌려 저장했다는 것을 알 수 있습니다.

이것도 그림으로 그려보면 이해하기 쉽습니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/printf-sort-tee-tail.svg )

[[/cmd/tee]]{tee}가 입력받은 출력을 파일로 빼돌리는 부분을 빨간색으로 표시했습니다.

[[/cmd/tee]]를 사용하면 이와 같이 중간에 값이 어떻게 되었는지를 확인하기 좋습니다.

### 명령 파이프라인의 마지막에 tee 사용하기 {#tee-at-the-end}

그런데 의외로 중간에서만 사용하는 것이 아니라 명령 파이프라인의 마지막에서도 [[/cmd/tee]]를 사용하는 경우가 은근히 많습니다.

```
printf "가위\n바위\n보\n" \
  | sort -R \
  | tail -1
  | tee result.txt
```

이렇게 하면 명령 파이프라인의 최종 출력이 어떻게 될까요?

화면으로도 출력되고, 파일로도 출력됩니다.

출력 결과가 수천줄이 넘어가는 명령 파이프라인의 경우에는 실행이 완료되고 나서 스크롤을 계속 올려서 처음부터 확인해야 하는 번거로움이 있을 수 있습니다.
하지만 이렇게 [[/cmd/tee]]를 마지막에 사용해주면 대량의 출력 결과 앞부분이 궁금할 때 귀찮게 스크롤하지 않고 그냥 파일을 열어서 앞부분만 확인할 수 있습니다.

```
 # less 뷰어로 열어서 원하는대로 스크롤
cat result.txt | less

 # head를 써서 첫 20줄만 확인
head -n 20 result.txt
```

시험삼아 [[/cmd/seq]]를 사용해 1부터 1000까지의 수를 출력하고, 이를 [[/cmd/tee]]로 연결해 봅시다.

```
seq 1000 | tee result.txt
```

이 명령을 실행하면 1부터 1000까지의 수가 1000줄에 걸쳐 순서대로 출력되므로 앞부분을 보려면 스크롤을 많이 올려야 합니다.

하지만 결과가 화면에 출력되긴 했지만 파일로도 똑같은 내용이 출력되었으므로 파일을 열어서 앞부분만 확인하면 됩니다.

```
$ wc -l result.txt  # 파일의 총 줄 수 확인
1000 result.txt

$ head result.txt   # 파일의 앞부분 10줄만 출력
1
2
3
4
5
6
7
8
9
10
```

### tee로 출력을 /dev/tty로 흘려보내기


작성중입니다...


## 주석

[^tee-image]: 이미지 출처는 [Piping and plumbing fitting (wikipedia.org)](https://en.wikipedia.org/wiki/Piping_and_plumbing_fitting ).
