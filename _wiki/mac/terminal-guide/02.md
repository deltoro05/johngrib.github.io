---
layout  : wiki
title   : macOS 초보를 위한 터미널 사용 가이드 - Week 02
summary : 작성중인 문서
date    : 2024-01-15 23:39:16 +0900
updated : 2024-01-19 23:08:57 +0900
tag     : 
resource: D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540
toc     : true
public  : true
parent  : [[/mac/terminal-guide]]
latex   : false
---
* TOC
{:toc}

## file descriptor 0, 1, 2 {#file-descriptor}

이번에는 셸 명령에서 중요한 0, 1, 2 를 공부해 보도록 하겠습니다.

우리가 명령을 입력해 실행하면, 프로세스가 생성됩니다.
그리고 프로세스는 기본적으로 3개의 file descriptor를 갖습니다.

- 0 : stdin, 표준입력
- 1 : stdout, 표준출력
- 2 : stderr, 표준에러 (표준에러 출력)

### 예제와 그림 {#example-and-picture}

이해를 돕기 위해 간단한 명령 중 하나인 [[/cmd/echo]]를 실행해 봅시다.

```
$ echo hello
hello
```

이걸 그림으로 표현해보겠습니다.
공식적인 유형의 그림은 아니고 제가 좋아하는 방식으로 마음대로 표현한 그림입니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/hello-process.svg )

- `echo`의 프로세스가 생성됐습니다.
- `echo`는 명령줄 인자로 `hello`를 받았습니다.
- 표준입력(`0`)으로 받은 것은 없습니다.
- 표준출력(`1`)으로 `hello`를 내보냈습니다.
    - 기본적으로 표준출력으로 내보내면 터미널 화면에 표시가 됩니다.
- 표준에러(`2`)로는 아무것도 내보내지 않았습니다.
    - 실행과정에서 에러가 없었기 때문입니다.

이제 이 여기에 [[/cmd/tr]]를 연결해 봅시다.

다음은 [[/cmd/echo]]의 출력을 [[/cmd/tr]]로 전달하는 파이프라인 명령입니다.

```
$ echo hello | tr l r
herro
```

- `echo hello`: `hello`를 출력.
- `tr l r`: `echo`의 출력인 `hello`를 받아서 `l`을 `r`로 바꾼 결과를 출력.

이것도 그림으로 그려보겠습니다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/hello-tr-process.svg )

파이프 (`|`) 를 통해 `echo`의 출력이 `tr`의 입력으로 전달되는 것이 눈에 보일 것입니다.

파이프는 이전 프로세스의 표준출력(`1`)을 다음 프로세스의 표준입력(`0`)으로 연결해 주겠다고 선언하는 것입니다.

그래서 [[/cmd/tr]]{tr}은 [[/cmd/echo]]{echo}의 출력인 `hello`를 받아서 `l`을 `r`로 바꾼 결과인 `herro`를 출력하게 되었습니다.

그렇다면 이번에는 결과를 터미널 화면이 아니라 파일로 리다이렉팅 해 봅시다.

아래의 명령 파이프라인과 같이 `echo | tr`의 출력을 `hello.txt` 파일로 보내면, `hello.txt` 파일에는 `herro`가 저장될 것입니다.

```
$ echo hello | tr l r > hello.txt

$ cat hello.txt
herro
```

다음은 이 과정을 그림으로 표현한 것입니다. [[/cmd/tr]]{tr}의 표준출력(`1`)이 `hello.txt` 파일로 리다이렉팅 되는 것에 주목합시다.

![]( /resource/D1/4F9D8A-0F3D-48BB-A643-865E1BBC5540/hello-tr-file-process.svg )

### Java의 System.in, System.out, System.err {#java-system-class}

이 가이드 문서를 통해 0, 1, 2 채널을 처음 알게 된 분들이 있다면, 생소하면서 신기한 느낌을 받고 있을지도 모르겠습니다.

그러나 평소 널리 알려져 있는 프로그래밍 언어를 통해 프로그래밍을 하고 있었다면 자신도 모르는 사이에 이들을 사용하고 있었을 것입니다.

예를 들어 [[/java]]의 `java.lang.System` 클래스를 열어보면 `in`, `out`, `err`이 있는데요, 이것들이 0, 1, 2 입니다.

- [open jdk(jdk-23+6)의 System.in](https://github.com/openjdk/jdk/blob/ff8cc268fdaaf85299c94088a226b73e7eaf6bdb/src/java.base/share/classes/java/lang/System.java#L128-L140 ): 표준입력(`0`)
    - 첫째줄의 `The "standard" input stream.` 이라는 주석이 표준입력(`0`)을 설명하고 있습니다.

```java
/**
 * The "standard" input stream. This stream is already
 * open and ready to supply input data. Typically this stream
 * corresponds to keyboard input or another input source specified by
 * the host environment or user. In case this stream is wrapped
 * in a {@link java.io.InputStreamReader}, {@link Console#charset()}
 * should be used for the charset, or consider using
 * {@link Console#reader()}.
 *
 * @see Console#charset()
 * @see Console#reader()
 */
public static final InputStream in = null;
```

- [open jdk(jdk-23+6)의 System.out](https://github.com/openjdk/jdk/blob/ff8cc268fdaaf85299c94088a226b73e7eaf6bdb/src/java.base/share/classes/java/lang/System.java#L142-L172 ): 표준출력(`1`)
    - 첫째줄의 `The "standard" output stream.` 이라는 주석이 표준출력(`1`)을 설명하고 있습니다.
    - 예를 들어 `System.out.print("str")`은 표준출력(`1`)으로 `str`을 보내는 것입니다.

```java
/**
 * The "standard" output stream. This stream is already
 * open and ready to accept output data. Typically this stream
 * corresponds to display output or another output destination
 * specified by the host environment or user. The encoding used
 * in the conversion from characters to bytes is equivalent to
 * {@link Console#charset()} if the {@code Console} exists,
 * <a href="#stdout.encoding">stdout.encoding</a> otherwise.
 * <p>
 * For simple stand-alone Java applications, a typical way to write
 * a line of output data is:
 * <blockquote><pre>
 *     System.out.println(data)
 * </pre></blockquote>
 * <p>
 * See the {@code println} methods in class {@code PrintStream}.
 *
 * @see     java.io.PrintStream#println()
 * @see     java.io.PrintStream#println(boolean)
 * @see     java.io.PrintStream#println(char)
 * @see     java.io.PrintStream#println(char[])
 * @see     java.io.PrintStream#println(double)
 * @see     java.io.PrintStream#println(float)
 * @see     java.io.PrintStream#println(int)
 * @see     java.io.PrintStream#println(long)
 * @see     java.io.PrintStream#println(java.lang.Object)
 * @see     java.io.PrintStream#println(java.lang.String)
 * @see     Console#charset()
 * @see     <a href="#stdout.encoding">stdout.encoding</a>
 */
public static final PrintStream out = null;
```

- [open jdk(jdk-23+6)의 System.err](https://github.com/openjdk/jdk/blob/ff8cc268fdaaf85299c94088a226b73e7eaf6bdb/src/java.base/share/classes/java/lang/System.java#L174-L192 )
    - 첫째줄의 `The "standard" error output stream. This stream is already` 이라는 주석이 표준에러출력(`2`)을 설명하고 있습니다.

```java
/**
 * The "standard" error output stream. This stream is already
 * open and ready to accept output data.
 * <p>
 * Typically this stream corresponds to display output or another
 * output destination specified by the host environment or user. By
 * convention, this output stream is used to display error messages
 * or other information that should come to the immediate attention
 * of a user even if the principal output stream, the value of the
 * variable {@code out}, has been redirected to a file or other
 * destination that is typically not continuously monitored.
 * The encoding used in the conversion from characters to bytes is
 * equivalent to {@link Console#charset()} if the {@code Console}
 * exists, <a href="#stderr.encoding">stderr.encoding</a> otherwise.
 *
 * @see     Console#charset()
 * @see     <a href="#stderr.encoding">stderr.encoding</a>
 */
public static final PrintStream err = null;
```

### /dev/fd

흥미로운 사실은 이런 0, 1, 2 가 내 컴퓨터의 하드디스크에 특수한 파일로 존재한다는 것입니다.

작성중...
