---
layout  : wiki
title   : macOS 초보를 위한 터미널 사용 가이드 - Week 00
summary : 학습목표, 준비물, 첫 실습
date    : 2024-01-13 21:57:43 +0900
updated : 2024-01-26 00:14:22 +0900
tag     : 
resource: C8/1CAC71-AAD6-4C15-9117-ED00C49D26CF
toc     : true
public  : true
parent  : [[/mac/terminal-guide]]
latex   : false
---
* TOC
{:toc}

- 다음 문서: [[/mac/terminal-guide/01]]

>
이 가이드는 제가 재직했던 여러 회사들에서 2019년부터 2023년까지 macOS에서의 터미널 사용에 익숙하지 않은 동료들을 위해 진행했던 세미나와 강연 등을 기억에 의지해 재구성한 것입니다.
>
잘못된 내용이 있을 수 있는데, 그런 경우엔 댓글이나 [이슈를 남겨주시면](https://github.com/johngrib/johngrib.github.io/issues/new?title=터미널사용가이드-이슈제보 ) 감사하겠습니다.

## 일러두기 {#preface}

이 가이드의 대상자는 다음과 같습니다.
- macOS 초심자
- 터미널에 관심은 있지만 어떻게 시작해야 할지 모르는 사람

이 가이드의 대상이 아닌 사람들은 다음과 같습니다.
- macOS 사용자가 아닌 사람
- 터미널 사용에 대해 관심과 필요를 못 느끼는 사람
- 터미널에 대해 이미 잘 알고 있는 사람

가이드의 목표

- macOS 초심자 또는 터미널에 공포를 느끼는 사람이, 터미널을 더 친숙하게 느끼고 두려움 없이 사용할 수 있도록 하는 것이 최종 목표입니다.

## 왜 터미널을 공부하죠? {#why}

터미널을 전혀 다룰 줄 몰라도 괜찮습니다.

- 현대적인 프로그래밍 도구들이 이미 충분한 기능들을 제공하고 있는 경우가 많습니다.
- 터미널 몰라도 대부분의 회사 업무를 하는 데에는 별다른 문제가 없습니다.
- 터미널 좀 쓴다고 프로그래밍을 더 잘 할 수 있는 것도 아닙니다.
- 터미널 실력이 뛰어난 프로그래머의 필수 조건도 아닙니다.
- 연봉 향상이나 취업에도 별로 도움이 되지 않습니다.

일종의 사이버 풍물놀이일 수 있습니다.

- 몰라도 됩니다. 그러나 알게 된다면 수십년 전에는 극소수의 기술 전문가들만 알고 있었던 흥미로운 세계를 탐험하는 지적 여행이 될 수 있습니다.
- 셸 명령들은 매우 오랜기간 사용되어 왔습니다.
    - 어쩌면 우리가 은퇴할 때까지 계속 쓸 수 있는 도구를 얻을 수 있는 기회일 수 있습니다.
    - 앞으로도 한동안 [[/cmd/ls]]{ls}, [[/cmd/grep]]{grep}, [[/cmd/find]]{find} 같은 명령들이 많이 쓰일 거라고 믿는다면 이들을 자유롭게 사용할 수 있도록 연습해 두는 것도 나쁘지 않을 것입니다.

GUI가 더 편리한 작업에서는 GUI를 쓰면 됩니다.
그러나 어떤 작업들은 CLI로 진행하는 것이 더 편리할 수 있습니다.

- 중요한 것은 내가 GUI와 CLI 중 선택을 할 수 있게 된다는 것입니다.
- 다음과 같은 경우 GUI보다 터미널의 CLI를 사용하는 것이 더 편리할 수 있습니다.
    - 하위 디렉토리의 특정한 이름을 가진 파일들만 선택해서
        - zip 압축 파일을 만들고 싶을 때
        - 삭제하고 싶을 때
    - 수천 개의 파일들을 찾아서 한꺼번에 이름을 바꾸고 싶을 때
    - 많은 양의 텍스트 파일에서 특수한 패턴을 가진 라인들만 찾고 싶을 때
        - 그렇게 찾은 내용을 다른 파일로 저장하고 싶을 때
    - 이런 작업들을 매번 일일이 마우스로 드래그해서 할 엄두가 나지 않을 때
    - ...

## 터미널? {#terminal}

macOS에서 사용하는 '터미널' 애플리케이션은 터미널 에뮬레이터입니다.
터미널 에뮬레이터는 터미널을 흉내내는 애플리케이션 프로그램을 말합니다.

다음은 1976년 무렵에 [[/people/bill-joy]]가 사용했다는 모델인 ADM-3A computer terminal의 사진입니다.

![]( /resource/C8/1CAC71-AAD6-4C15-9117-ED00C49D26CF/440px-Adm3aimage.jpg )[^pic-adm3a]

데스크탑 컴퓨터처럼 생겼지만, 터미널은 컴퓨터가 아니고 컴퓨터에 연결되어 입출력을 주고받는 단말 장치입니다.
이해하기 쉽게 설명하자면 키보드와 모니터를 한 제품으로 만든 것이라고도 할 수 있습니다.

![]( /resource/C8/1CAC71-AAD6-4C15-9117-ED00C49D26CF/adm-3a-keyboard.webp )[^pic-adm3a-keyboard]

위의 사진은 ADM-3A의 키보드입니다.
2024년 기준의 최신 키보드들과는 다른 점들이 눈에 띕니다.

- 방향키가 따로 없고, HJKL 위에 방향키가 오버되어 있습니다.
- 몇 가지 중요한 키가 안 보입니다.
    - 한 글자를 지우는 키, 백 스페이스가 없습니다. [[/special-chars#backspace]]{대신 ctrl + h 를 사용했습니다.}
    - 탭 키가 없습니다. [[/special-chars#tab]]{대신 ctrl + i 를 사용했습니다.}
    - Enter가 없고 [[/special-chars#cr-lf]]{Return과 Line Feed가 있습니다.}
    - Caps Lock이 없습니다. 옛날엔 대문자만 썼습니다...
    - alt / option 키가 없습니다.
    - ...
- Shift와 조합하는 몇몇 특수문자들의 위치가 다릅니다.
    - `"`, `"`, `~`, `+`, `^`, `:` 등등

## 준비물

### 단축키로 바로 부를 수 있는 터미널 에뮬레이터

터미널에 익숙해지기 위해 노력하는데도 잘 안 되는 이유 중 하나는 터미널 실행이 번거롭기 때문일 수 있습니다.

- Spotlight를 열고 'Terminal'을 입력하고 엔터를 누른다?
- Dock에서 터미널을 마우스로 클릭한다?
- 터치패드에서 네 손가락을 오므려 '데스크탑 보기'를 한 다음 터미널을 더블 클릭한다?

모두 귀찮은 방법입니다.
연습을 시작한 지 몇 분도 지나지 않아 터미널 실행을 귀찮아하게 될 것입니다.
단축키로 실행할 수 있는 터미널 에뮬레이터를 사용하는 것이 편리합니다.

[[/mac/iterm]]이 그런 기능을 제공하는 대표적인 터미널 에뮬레이터입니다. 아래와 같이 설정하면 됩니다.

![]( /resource/C8/1CAC71-AAD6-4C15-9117-ED00C49D26CF/iterm-hotkey.jpg )

위의 이미지와 같이 설정하면 `option + space`를 누르는 것으로 터미널을 실행하거나, 터미널 화면으로 전환할 수 있습니다.

물론 다른 터미널도 괜찮습니다.
macOS에서 돌아가는 터미널 에뮬레이터는 여러 가지가 있습니다.
OS에 기본으로 포함되어 있는 터미널 애플리케이션을 사용해도 되고, 다른 터미널 애플리케이션을 설치해서 사용해도 됩니다.
그러나 가급적이면 단축키로 바로 부를 수 있는 터미널 에뮬레이터를 사용하는 것이 편리합니다.

저는 [[/mac/iterm]]을 사용하지 않고, [[/tools/alacritty]]를 사용하지만 [[/hammerspoon]]을 통해 단축키로 실행할 수 있도록 설정해두고 있습니다.

### Homebrew 설치 {#brew}

[[/cmd/brew]], 또는 `brew`는 macOS에서 널리 사용되는 패키지 매니저입니다.
이 가이드에서는 `brew`를 사용하는 예제가 여러 차례 등장할 예정입니다.

>
[[/cmd/brew]] 외에도 macOS에서 사용 가능한 패키지 매니저는 여럿이 있습니다.
그리고 [[/cmd/brew]]는 꾸준히 비판받는 몇 가지 단점들도 있습니다.
그러나 `brew`는 macOS 컴퓨터에서 프로그래밍을 하는 사람이라면 누구나 알고 있고, 사용하는 사람도 많이 있습니다.
이 가이드는 초심자를 위한 것이므로 `brew`를 사용합니다.
>
다른 패키지 매니저를 익숙하게 사용하고 있는 사람이라면 이 가이드를 읽을 필요가 없을 수 있습니다.
그래도 이 가이드를 읽고 따라하겠다면 `brew` 명령을 사용하는 곳에서는 자신이 사용하고 있는 패키지 매니저의 명령을 사용하면 됩니다.
{:style="background-color: #ecf1e8;"}

<https://brew.sh/index >로 들어가서 "Install Homebrew" 섹션에 있는 명령을 복사해서 터미널에 붙여넣으면 `brew`명령이 내 컴퓨터에 설치됩니다.
이 명령을 통해 다양한 터미널용 프로그램과 데스크탑 애플리케이션을 설치/업그레이드/삭제하는 등의 작업을 할 수 있습니다.

`brew` 명령의 편리한 점은 간단한 명령을 입력해 내 컴퓨터에 없었던 프로그램을 설치할 수 있다는 것입니다.

예를 들어 다음과 같인 간단한 명령으로 Go 프로그래밍 언어를 다운로드 받아서 설치까지 한 번에 할 수 있습니다.

```bash
brew install go
```

홈페이지를 찾아가서 설치 프로그램을 다운로드 받고, 설치 마법사를 실행하고, "다음" 키를 반복해서 누르는 등의 귀찮은 작업을 하지 않아도 됩니다.

## 첫 파이프라인 셸 명령

### 한 줄짜리 가위바위보 프로그램 만들기 {#one-line-rsp}

단축키를 입력해 터미널을 부른 다음, 다음과 같이 입력합니다.

```bash
printf "가위\n바위\n보\n"
```

출력은 다음과 같은 결과를 볼 수 있습니다.

```
$ printf "가위\n바위\n보\n"
가위
바위
보
```


이제 이 출력을 다른 명령과 연결해 봅시다. [[/cmd/sort]]와 연결해보죠.

```
$ printf "가위\n바위\n보\n" | sort
보
가위
바위
```

정렬된 결과를 볼 수 있습니다. (글자수가 한 글자인 `보`가 가장 먼저 나왔습니다.)
[[/cmd/sort]]는 이와 같이 아무런 옵션을 주지 않으면 기본적으로 문자열/오름차순 기준으로 정렬을 합니다.

만약 내림차순으로 정렬하고 싶다면 [[/cmd/sort#option-r]]{-r 옵션}을 주면 됩니다.

```
$ printf "가위\n바위\n보\n" | sort -r
바위
가위
보
```

가위 바위 보 게임은 사실 랜덤 게임입니다. 그러니 가위/바위/보의 순서로 랜덤으로 출력되도록 해봅시다.

[[/cmd/sort#option-random]]{-R 옵션(랜덤 정렬)}을 사용하면 됩니다.

```
$ printf "가위\n바위\n보\n" | sort -R
가위
보
바위
```

이 명령을 반복해서 실행해보면 매번 결과가 다르게 나오는 것을 볼 수 있습니다.
참고로 이전 명령을 쉽게 입력하려면 명령행에서 `↑` 키를 누르면 됩니다.

이번에는 [[/cmd/sort]] 뒤에 `head` 명령을 연결해 봅시다.
이 명령은 주어진 파일의 첫 10줄을 출력하는 명령이지만, 옵션으로 몇 줄을 출력할지 지정할 수 있습니다.

`-1`을 주면 첫 번째 줄만 출력합니다.

```
$ printf "가위\n바위\n보\n" | sort -R | head -1
바위

$ printf "가위\n바위\n보\n" | sort -R | head -1
보
```

중간에 `sort -R`이 있기 때문에 실행할 때마다 가위/바위/보 중 하나가 나오게 되었습니다.

한 줄짜리 가위바위보 게임이 완성된 셈입니다.

### 결과를 파일로 저장하기

위에서 만든 가위바위보 게임의 결과를 파일로 저장해 봅시다.

마지막의 `head -1` 명령은 결과를 우리 눈에 보이는 모니터 스크린으로 출력하고 있습니다.
이 출력 방향을 바꿔서 파일로 연결해주면, 결과가 모니터로 출력되지 않고 파일로 출력(저장)됩니다.

출력 방향은 `>` 기호를 사용해 지정할 수 있습니다.

다음은 `result.txt` 라는 파일로 출력 방향을 전환한 것입니다.

```
$ printf "가위\n바위\n보\n" | sort -R | head -1 > result.txt
```

이제 `result.txt` 파일이 생겨나 있을 것입니다.

파일의 내용을 보려면 `cat` 명령을 사용하면 됩니다.

```
$ cat result.txt
보
```

물론 파일의 첫 10줄을 보여주는 명령인 `head`를 사용해도 됩니다.

```
$ head result.txt
보
```

그런데 이 명령 조합을 사용할 때마다 `result.txt` 파일이 매번 덮어쓰기된다는 것을 알 수 있을 것입니다.
`>`를 써서 출력 방향을 파일로 바꿔주면 매번 새로운 파일을 생성하기 때문입니다.

이를 방지하려면 `>>`를 사용하면 됩니다. `>>`는 파일이 존재하면 파일 끝에 내용을 추가하고, 파일이 존재하지 않으면 새로 생성하게 해줍니다.

```
$ printf "가위\n바위\n보\n" | sort -R | head -1 >> result.txt
```

이 명령을 여러 차례 실행한 다음 `result.txt` 파일의 내용을 확인해 봅시다.

```
$ cat result.txt 
보
바위
가위
바위
가위
바위
가위
가위
바위
바위
가위
보
가위
```

`cat` 명령을 사용할 때 `-n` 옵션을 주면 줄 번호를 같이 출력해줍니다.

```
$ cat -n result.txt 
     1	보
     2	바위
     3	가위
     4	바위
     5	가위
     6	바위
     7	가위
     8	가위
     9	바위
    10	바위
    11	가위
    12	보
    13	가위
```

`head`를 쓰면 첫 10줄만 볼 수 있습니다. 마지막의 세 줄은 보이지 않습니다.

```
$ head result.txt 
보
바위
가위
바위
가위
바위
가위
가위
바위
바위
```

[[/cmd/tail]]는 `head`와 정반대의 작업을 합니다. 즉, 마지막 10줄을 보여줍니다.

```
$ tail result.txt 
바위
가위
바위
가위
가위
바위
바위
가위
보
가위
```

[[/cmd/sort]]도 이 파일에 사용할 수 있습니다. 그러나 `head`, `tail`과는 달리 정렬된 결과가 출력됩니다.

```
$ sort result.txt 
보
보
가위
가위
가위
가위
가위
가위
바위
바위
바위
바위
바위
```

물론 `cat`의 결과에 [[/cmd/sort]]를 연결해도 똑같습니다.

```
$ cat result.txt | sort
보
보
가위
가위
가위
가위
가위
가위
바위
바위
바위
바위
바위
```

여기에 [[/cmd/uniq]]를 사용하면 중복을 제거할 수 있습니다.

```
$ sort result.txt | uniq
보
가위
바위
```

[[/cmd/uniq]]는 정렬된 입력을 받아야 중복을 제대로 제거할 수 있으므로, [[/cmd/sort]]와 함께 사용하는 경우가 많습니다.
자주 사용하는 조합이므로 점점 익숙해질 것입니다.

이번에는 중복을 그냥 제거하지 말고 카운트를 세주는 [[/cmd/uniq#option-c]]{uniq의 -c 옵션}을 사용해 봅시다.

```
$ sort result.txt | uniq -c
   2 보
   6 가위
   5 바위
```

가위 바위 보의 통계가 나왔습니다!

기왕 나온 김에 [[/cmd/sort#option-n]]{sort -n}을 사용해 숫자 오름차순으로 정렬을 해 줍시다.

```
$ sort result.txt | uniq -c | sort -n
   2 보
   5 바위
   6 가위
```

그냥 [[/cmd/sort]]를 사용해도 되지만 굳이 [[/cmd/sort#option-n]]{sort -n}을 사용했습니다.
`-n` 옵션을 주면 문자열이 아니라 숫자로 인식해서 정렬해 주기 때문입니다.
다양한 상황에서 `-n`을 사용해보거나 하면서 차이점을 비교해 보세요.

이제 여기에 [[/cmd/tail]]{tail -1 명령}을 연결하면 가장 많이 나온 것이 무엇인지 알 수 있습니다.

```
$ sort result.txt | uniq -c | sort -n | tail -1
   6 가위
```

가장 많이 나온 것은 `가위`이며 6번 나왔다는 것을 알 수 있습니다.

## 다음 문서

- 다음 문서: [[/mac/terminal-guide/01]]

## 주석

[^pic-adm3a]: 사진 출처는 [wikipedia의 ADM-3A 문서](https://en.wikipedia.org/wiki/ADM-3A ).
[^pic-adm3a-keyboard]: 사진 출처는 [reddit r/vim의 게시글: All these Vim keyboards and nobody’s gonna post THE ORIGINAL Vim keyboard?? (Lear-Siegler ADM-3A)](https://www.reddit.com/r/vim/comments/alwsdq/all_these_vim_keyboards_and_nobodys_gonna_post/ )
