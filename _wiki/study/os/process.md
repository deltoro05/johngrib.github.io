---
layout  : wiki
title   : process
summary : 
date    : 2023-07-08 23:04:05 +0900
updated : 2023-07-24 22:39:32 +0900
tag     : 
resource: A2/AED112-D4E0-4FB4-8F37-FFF4950CD9EC
toc     : true
public  : true
parent  : [[/study/os]]
latex   : false
---
* TOC
{:toc}

## 프로세스

>
운영체제는 **실행 중인 프로그램**의 개념을 제공하는데, 이를 **프로세스(process)**라 한다.
[^three-28]
>
현재 실행되고 있는 프로그램의 한 인스턴스를 프로세스(process)라고 부른다.
[^unix-14]


<span/>

>
- **프로세스**는 실행중인 프로그램을 나타내는 개념이다. 프로세스는 프로세스의 상태, 프로세스 주소공간에 있는 메모리 변수 값들, 레지스트 값들(스택 포인터, 프로그램카운터 등), 그리고 입출력 관련정보(사용중인 파일들)들로 표현된다.
- **프로세스 API**는 프로세스와 관련된 함수들을 일컫는다. 프로세스의 생성, 삭제 등에 관련된 함수들이다.
- 프로세스에는 다양한 **프로세스 상태**가 있다. 실행, 대기, 블럭 등이 그것이다. 특정사건의 발생(CPU의 할당, CPU의 반납, 입출력 요청, 입출력 완료 등)으로 인해 프로세스의 상태가 변화한다.
- **프로세스 리스트**는 시스템에 존재하는 모든 프로세스에 대한 정보를 갖는다. 이 리스트의 각 노드는 프로세스 제어블럭이다.
[^three-35]

<span/>

>
- UNIX 시스템에서는 fork 시스템 콜을 사용하여 새로운 프로세스를 생성한다. 생성의 주체가 부모가 되고 새롭게 생성된 프로세스가 자식이 된다. 실세계에서도 종종 있는 일이지만, 자식 프로세스는 부모의 판박이 일때가 있다.
- `wait()` 시스템 콜은 자식 프로세스의 실행이 종료할 때까지 부모가 기다리도록 한다.
- `exec()` 계열의 시스템 콜은 자식 프로세스가 부모와의 연관성을 완전히 끊어서 완전히 새로운 프로그램을 실행할 수 있도록 한다.
- UNIZ 쉘은 보통 `fork()`, `wait()` 그리고 `exec()`를 사용하여 사용자의 명령을 시작한다. `fork()`와 `exec()` 명령을 분리하였기 때문에 실행 중인 프로그램을 조작하지 않고도 **입력/출력 재지정, 파이프,** 그리고 다른 기능들을 처리하는 것이 가능하다.
- 프로세스 제어는 **시그널**이라는 형태로 제공되며, 이를 활용하여 작업을 멈추고, 계속 실행하고, 종료시킬 수 있다.
- 누가 어떤 프로세스를 제어 할 수 있냐는 **사용자**라는 개념 속에 포함되어 있다. 여러 사용자가 시스템을 사용할 수 있도록 허용하는 것과 사용자가 자신의 프로세스만 제어할 수 있게 만드는 것을 운영체제가 책임진다.
- **슈퍼사용자**는 모든 프로세스들을 제어할 수 있다(그 외에도 많은 일들을 할 수 있다). 이 역할은 간헐적으로 맡아야 하며, 보안상의 이유로 조심스럽게 대처해야 한다.
[^three-49]

## 프로세스 ID, PID {#pid}

>
- 각 프로세스는 이름이 있다. 대부분의 시스템에서 이름은 **프로세스 ID(PID)**라는 번호이다.
[^three-49]

<span/>

>
UNIX 시스템은 모든 프로세스에 각자 고유한 수치 식별자가 있음을 보장한다.
그런 식별자를 프로세스 ID라고 부른다.
프로세스 ID는 항상 음이 아닌 정수이다.
[^unix-14]

<span/>

>
커널은 각 프로세스에 하나의 고유한 ID 번호를 배정한다.
프로세스를 다루는 대부분 명령과 시스템 콜은 작업의 대상을 특정하기 위한 PID를 지정할 것을 요구한다.
PID는 프로세스가 생성되는 순서대로 배정된다.
[^handbook-183]

## 시그널 {#signal}

[[/study/os/signal]]

## 프로세스 생성

- 프로그램 실행을 위해 OS가 하는 작업들
    - 해당 프로그램의 코드와 정적 데이터를 메모리와 프로세스의 주소 공간에 load한다.
    - 해당 프로그램을 위한 stack을 특정 크기의 메모리 공간에 할당한다.
    - 해당 프로그램을 위한 heap을 특정 크기의 메모리 공간에 할당한다.
    - 해당 프로그램을 위한 입출력 관련 초기화 작업.
        - UNIX 시스템이라면 표준 입력(STDIN), 표준 출력(STDOUT), 표준 에러(STDERR)와 같은 파일 디스크립터를 할당한다.

>
코드와 정적 데이터를 메모리에 탑재하고, 스택과 힙을 생성하고 초기화하고, 입출력 셋업과 관계된 다른 작업을 마치게 되면, 운영체제는 프로그램 실행을 위한 준비를 마치게 된다.
프로그램의 시작 지점(entry point), 즉 `main()`에서부터 프로그램 실행을 시작하는 마지막 작업만이 남는다.
`main()` 루틴으로 분기함으로써 (다음 장에서 이를 가능하게 하는 특수 기법을 설명할 것이다), <mark>운영체제는 CPU를 새로 생성된 프로세스에게 넘기게 되고 프로그램 실행이 시작된다</mark>.
[^three-31]

## 참고문헌

- UNIX 고급 프로그래밍 [제3판] / 리처드 스티븐스, 스티븐 레이고 공저 / 류광 역 / 퍼스트북 / 인쇄일: 2014년 08월 28일 / 원제: Advanced Programming in the UNIX Environment
- 운영체제 아주 쉬운 세 가지 이야기 [제2판] / Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-dusseau 공저 / 원유집, 박민규, 이성진 공역 / 홍릉 / 제2판 발행: 2020년 09월 10일 / 원제: Operating Systems: Three Easy Pieces
- 유닉스·리눅스 시스템 관리 핸드북 5/e / 에비 네메스, 가스 스나이더, 트렌트 헤인, 벤 웨일리, 댄 맥킨 저 외 2명 / 에이콘출판사 / 발행: 2022년 01월 03일 / 원제: UNIX and Linux System Administration Handbook, 5th Edition

## 주석

[^three-28]: 운영체제 아주 쉬운 세 가지 이야기. 4.1장. 28쪽.
[^three-31]: 운영체제 아주 쉬운 세 가지 이야기. 4.3장. 31쪽.
[^three-35]: 운영체제 아주 쉬운 세 가지 이야기. 4.5장. 35쪽.
[^three-49]: 운영체제 아주 쉬운 세 가지 이야기. 5.7장. 49쪽.
[^unix-14]: UNIX 고급 프로그래밍. 1.6장. 14쪽.
[^handbook-183]: 유닉스·리눅스 시스템 관리 핸드북. 4장. 183쪽.

