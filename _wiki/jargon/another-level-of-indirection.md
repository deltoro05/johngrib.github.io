---
layout  : wiki
title   : 또 다른 수준의 간접층
summary : Another level of indirection
date    : 2022-09-09 17:43:57 +0900
updated : 2022-09-09 18:16:24 +0900
tag     : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

>
All problems in Computer Science can be solved by another level of indirection.
>
전산학의 모든 문제는 또 다른 수준의 간접층으로 해결할 수 있다.

## From: Beautiful Code

>
"전산학의 모든 문제는 또 다른 수준의 간접층(level of indirection)으로 해결할 수 있다"라는 유명한 인용구가 있다.
이 말은 1972년에 현대적인 개인용 컴퓨터를 예견한 바 있는 과학자 램슨<sup>Butler Lampson</sup>이 한 것으로 알려져 있다.
이런 인용구가 생각나는 상황은 흔하다.
예를 들어 정말로 대화하고자 하는 사람이 아니라 그의 비서와 이야기해야 할 때, 동쪽의 상하이나 방갈로어로 가기 위해 우선 서쪽의 프랑크푸르트로 가야 할 때 등등.
물론, 복잡한 시스템의 소스 코드를 조사할 때에도 이 인용구가 머리에 떠오른다.
>
-- 17장. 371쪽.

<span/>

### But that usually will create another problem

>
끝으로 이 여정의 시작에서 언급한 인용구(전산학의 모든 문제는 또 다른 수준의 간접층으로 해결할 수 있다)에 대한 이야기를 좀 더 추가하고자 한다.
인용구의 출처는 램슨이라고 알려져 있지만, 사실 램슨 자신은 그것이 서브루틴을 창안한 휠러<sup>David Wheeler</sup>에서 비롯된 말이라고 밝힌 바 있다.
흥미롭게도 휠러는 그 인용구에 다음과 같은 또 다른 인용구를 붙여 놓았다: **"그러나 그러면 또 다른 문제가 생기는 것이 일반적이다."** 실제로, 간접과 계층화는 공간과 시간의 부담을 추가하며 코드의 가독성을 해칠 수 있다.
>
그러한 시간과 공간상의 추가부담은 그리 크지 않기 때문에 큰 관심사가 되지 못한다.
대부분의 경우 추가적인 포인터 참조나 서브루틴 호출에 의한 시간 지연은 전반적인 구조 개선에 비할 때 사소한 수준에 그친다.
사실 요즘의 현대적 프로그래밍 언어들은 추가적인 유연성을 얻기 위한 목적으로 일부 연산들의 경우 항상 하나의 간접층을 거치도록 하는 경향을 보이고 있다.
예를 들어 Java나 C#에서는 객체에 대한 모든 접근이 하나의 포인터 간접을 거치게 하는데, 이는 쓰레기 수거(garbage collection)를 위한 것이다.
또한 Java에서는 인스턴스 메서드에 대한 거의 모든 호출이 하나의 조회 테이블을 통해서 분배되는데, 이는 다른 클래스를 상속하는 클래스들이 실행시점에서 메서드를 재정의할 수 있도록 하기 위한 것이다.
>
(중략)
>
반면 코드의 가독성에 대한 간접의 영향은 아주 중요한 문제이다.
지난 50년간 CPU 속도는 엄청나게 빨라진 반면 코드를 이해하는 사람의 능력은 별로 발전하지 않았다는 점을 감안한다면 충분히 이해할 수 있을 것이다.
그래서 애자일(Agile) 프로세스 옹호자들은 오늘의 구체적인 요구가 아니라 미래에 생길 수도 있는 애매하고 명시되지 않은 요구사항들을 처리하기 위해 계층들을 도입할 때에는 아주 신중해야 한다고 조언한다.
성능 안티패턴을 논의하면서 스몰더스<sup>Bart Smaalders</sup>는 이에 대해 "계층은 케이크를 위한 것이지 소프트웨어를 위한 것이 아니다."라고 비꼰 바 있다.
>
-- 17장. 385쪽.

## From: Prefactoring

>
**간접 지정**
>
자주 인용되는 컴퓨터 과학의 법칙이 있다.
'컴퓨터 과학의 거의 모든 문제는 또 다른 간접 지정 수준(level of Indirection)을 통해서 해결될 수 있다.'
혹자는 '지나치게 많은 간접 지정 수준 때문에 유지 보수에 문제가 발생할 수 있다'고 불평하기도 한다.
하지만 다른 여러 설계 특징들처럼, 간접 지정을 만드는 것은 나중에 추가하는 것보다 쉽다.
>
-- 11장. 201쪽.

<span/>

>
**패러다임 불일치**
>
때때로 내부적인 구현에 대한 패러다임과 여러분이 만든 인터페이스의 패러다임이 일치하지 않을 수 있다.
보통 이러한 차이점을 감추기 위해서 어댑터를 만든다.
>
-- 11장. 206쪽.

## 참고문헌

- Beautiful Code / 찰스 페졸드 외 37 저 / 류광 옮김 / 한빛미디어 / 초판발행 2007년 12월 17일
- [Beautiful Code - Chapter 17. Another Level of Indirection]( https://www2.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html )
- 프리팩토링 / 켄 푸 저 / 서우석 역 / 한빛미디어 / 초판 발행 2006년 10월 20일
