---
layout  : wiki
title   : 마이크로서비스 아키텍처 스타일
summary : 
date    : 2023-03-01 14:19:01 +0900
updated : 2023-03-01 17:14:14 +0900
tag     : 
resource: B3/291923-BC2F-4A30-ABED-40F1AA3CE273
toc     : true
public  : true
parent  : [[/pattern]]
latex   : false
---
* TOC
{:toc}

## From: martinfowler.com

[Microservices][fowler-microservices]

## From: 소프트웨어 아키텍처 101

>
대부분의 아키텍처 스타일은 반복적으로 나타나는 패턴을 처음 발견한 아키텍트의 이름을 따서 명명합니다.
즉, 다음에 유행할 아키텍처 스타일을 결정하는 비밀 아키텍트 그룹 따위가 있는 게 아니라,
외려 소프트웨어 개발 생태계가 변화하면서 많은 아키텍트들은 공통의 결정에 이르는 것이 일반적입니다.
이런 변화의 물결에 대응하면서 장점을 취하는 최선의 방법이 다른 사람들이 흉내내는 아키텍처 스타일이 되는 것입니다.
>
이런 점에서 마이크로서비스는 사뭇 다릅니다.
사용 초기부터 이름이 붙여졌고 2014년 3월 마틴 파울러<sup>Martin Fowler</sup>와 제임스 루이스<sup>James Lewis</sup>가 쓴 ['Mircroservices'라는 유명한 블로그 게시글][fowler-microservices] 덕분에 널리 퍼지게 되었죠.
두 사람은 비교적 새로운 이 아키텍처 스타일에서 많은 공통점을 찾아냈고, 그들이 쓴 블로그 게시글은 호기심 많은 아키텍트들이 아키텍처를 정의하고 그 하부에 내재된 철학을 이해하는 데 도움을 주었습니다.
>
마이크로서비스는 소프트웨어 프로젝트의 논리적 설계 프로세스를 강조한 도메인 주도 설계<sup>domain-driven design</sup>(DDD) 사상의 영향을 많이 받았습니다.
특히, 디커플링 스타일을 나타낸 경계 콘텍스트<sup>bounded context</sup> 개념은 마이크로서비스에 결정적인 영향을 미쳤습니다.
개발자가 정의한 도메인에는 코드, 데이터베이스 스키마 같은 아티팩트에서 식별되는 수많은 엔티티와 행위가 포함됩니다.
예를 들어, CatalogCheckout 도메인은 카탈로그 항목, 고객, 결제 등의 개념을 갖고 있습니다.
전통적인 모놀리식 아키텍처에서 개발자는 이런 수많은 개념을 공유하고 재사용 가능한 클래스를 만들어 데이터베이스에 접속했습니다.
경계 콘텍스트 내부에서는 코드, 데이터 스키마 같은 내부 요소들이 함께 연결되어 작동되지만, 경계 콘텍스트 외부에 있는 것들(예: 데이터베이스, 클래스 정의)은 전혀 커플링되지 않습니다.
이로써 각 콘텍스트는 다른 구성원을 수용하지 않고 자신이 필요한 것들만 정의할 수 있습니다.
>
재사용은 유익하지만 커플링이 문제입니다(소프트웨어 아키텍처 제1법칙).
재사용을 선호하는 시스템을 설계하다 보면 결국 상속이나 조합을 이용하여 재사용하기 위해 커플링이 맺어지게 됩니다.
>
그러나 고도의 디커플링이 아키텍트의 목표라면 재사용보다 중복을 우선할 것입니다.
마이크로서비스의 주요 목표는 경계 콘텍스트의 논리적 개념을 물리적으로 모델링하는 고도의 디커플링입니다.
[^mark-301]

### bounded context

>
마이크로서비스의 근본 철학은 경계 콘텍스트<sup>bounded context</sup> 개념입니다.
서비스마다 도메인이나 워크플로를 모델링하는 개념이지요.
클래스, 기타 부속 컴포넌트, 데이터베이스 스키마 등 애플리케이션 작동에 필요한 모든 것들이 각 서비스에 들어갑니다.
이러한 사고 방식은 아키텍트의 결정에 지대한 영향을 미칩니다.
예를 들어, 모놀리스 사고 방식으로는 Address 같은 공통 클래스를 다른 애플리케이션 파트의 개발자가 공유하는 것이 당연하지만,
마이크로서비스 는 커플링을 가급적 삼가므로 이 아키텍처 스타일을 구축하는 아키텍트는 커플링보다는 차라리 중복이 낫다고 생각합니다.
>
마이크로서비스는 도메인 분할 아키텍처의 개념을 극도로 우려낸 결과물입니다.
각각의 마이크로서비스는 어느 한 도메인이나 그 서브도메인을 나타냅니다.
여러 면에서 마이크로서비스는 도메인 주도 설계의 논리적인 개념을 물리적으로 구현한 것입니다.
[^mark-304]

## 주의할 점

### 성능 문제

>
마이크로서비스의 분산 속성 탓에 성능은 다소 부정적입니다.
아무래도 네트워크 호출은 메서드 호출보다 오래 걸리고 엔드포인트마다 보안 검증 절차를 거치면 그만큼 처리 시간이 소요되므로
시스템을 설계하는 아키텍트는 서비스 세분도에 대해 심사숙고해야 합니다.
>
마이크로서비스는 분산 아키텍처의 일종이므로 숙련된 아키텍트라면 개발자가 서비스 경계를 넘나드는 트랜잭션을 사용하지 않도록 권고해야 합니다.
이 아키텍처는 서비스를 얼마나 세분화할 것인가를 잘 결정하는 것이 성공의 관건입니다.
[^mark-304]

<span/>

>
마이크로서비스는 성능 문제가 불거질 때가 많습니다.
분산 아키텍처는 특성상 작업을 완료하기 위해 잦은 네트워크 호출을 해야 하므로 성능 오버헤드가 높고, 엔드 포인트마다 신원 및 접근 권한을 확인하는 보안 체크도 해야 합니다.
마이크로서비스 세상에서는 과도한 네트워크 호출을 줄이고 성능을 개선하기 위해 데이터 캐시, 데이터 복제 등의 기술을 많이 사용합니다.
커플링이 적을수록 통신 속도가 증가하고 병목이 줄기 때문에 오케스트레이션보다는 코레오그래피를 더 많이 사용하는 편입니다.
[^mark-323]

## 참고문헌

- [Microservices (martinfowler.com)]( https://martinfowler.com/articles/microservices.html )
- 소프트웨어 아키텍처 101 / 마크 리처즈, 닐 포드 저/이일웅 역 / 한빛미디어 / 초판 1쇄 발행 2021년 11월 01일 / 원제: Fundamentals of Software Architecture

## 주석
[^mark-301]: 소프트웨어 아키텍처 101. 17장. 301쪽.
[^mark-304]: 소프트웨어 아키텍처 101. 17장. 304쪽.
[^mark-323]: 소프트웨어 아키텍처 101. 17장. 323쪽.
[fowler-microservices]: https://martinfowler.com/articles/microservices.html

